<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>ydsungan的博客</title>
        <link>http://ydsungan.com/</link>
        <description>Recent content on ydsungan的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Wed, 30 Mar 2022 14:30:12 +0800</lastBuildDate><atom:link href="http://ydsungan.com/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>页缓存、直接IO与内存映射</title>
        <link>http://ydsungan.com/p/%E9%A1%B5%E7%BC%93%E5%AD%98%E7%9B%B4%E6%8E%A5io%E4%B8%8E%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/</link>
        <pubDate>Wed, 30 Mar 2022 14:30:12 +0800</pubDate>
        
        <guid>http://ydsungan.com/p/%E9%A1%B5%E7%BC%93%E5%AD%98%E7%9B%B4%E6%8E%A5io%E4%B8%8E%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/</guid>
        <description>&lt;p&gt;​		对文件系统中结构的修改都是直接在存储设备中进行的。然而在存储设备上直接访问数据有两个问题。首先，目前大多数存储设备都是块接口，读写粒度为—个块，大小通常为 512B 或者 4KB。然而文件系统所进行的更改往往并非对齐到块的边界，其读写的字节数也并非恰好为块大小的整数倍。其次，存储设备的访问速度慢，与内存相比要慢几个数量级。大量频繁的存储设备访问操作会成为应用程序的性能瓶颈。&lt;/p&gt;
&lt;h2 id=&#34;1-访问粒度不一致问题和一些优化&#34;&gt;1 访问粒度不一致问题和一些优化&lt;/h2&gt;
&lt;p&gt;​		文件系统使用内存作为中转来解决访问粒度不—致的问题。假设一个存储设备的块大小为 4KB。当文件系统需要修改存储设备中的 8B 时，其需要先从存储设备中找到这8个字节所在的块号。通过块号，文件系统将整个块中的数据读入一个 4KB 大小的内存页之中。文件系统在内存页中修改这8个字节，并将修改后的内存页通过驱动写回到存储设备之中。这实际上是一个“读取—修改—写回”的过程。&lt;/p&gt;
&lt;p&gt;​		其中一个明显的问题是，若每个文件请求中每个结构的修改都经过完整的 “&lt;strong&gt;读取-修改-写回&lt;/strong&gt;” 过程，将会产生大量的磁盘访问。有一些比较简单的优化可以避免一些不必要的磁盘访问。&lt;/p&gt;
&lt;p&gt;​		之所以要在修改和写回之前先读取，是因为我们只想修改存储块下的一部分，而写回操作会覆盖整个存储块。为了保证此存储块中其他部分的数据不变，我们需要先将这些数据读出来，之后随修改后的数据一同写回到存储设备中。但是，如果一次修改的数据量刚好覆盖了整个存储块，那么就不用进行读取操作，可以直接将修改后的4096个字节写回到存储设备中。&lt;/p&gt;
&lt;p&gt;​		此外，如果一个文件请求中的多次修改均是在同—个存储块中，那么可以将多次修改合并到一个 “&lt;strong&gt;读取-修改-写回&lt;/strong&gt;” 的过程中，即变为 “&lt;strong&gt;读取-修改1-修改2-修改3-…修改n-写回&lt;/strong&gt;” 。这样，同样访问了两次存储设备，却完成了多次修改。&lt;/p&gt;
&lt;h2 id=&#34;2-读缓存&#34;&gt;2 读缓存&lt;/h2&gt;
&lt;p&gt;​		文件的访问具有时间局部性：当文件的一部分被访问后，有较高的概率其会再次被使用。因此，当文件系统从设备中读取了某个文件的数据之后，可以让这些数据继续保留在内存中一段时间。这样，当应用程序需要再次读取这些数据时，就可以从此前保留在内存中的数据中读取，从而避免了存储设备的访问。这便是文件系统中的读缓存。&lt;/p&gt;
&lt;p&gt;​		读缓存是需要占用内存空间的。为了防止该缓存占用过多的内存，澡作系统会对读缓存的大小进行限制。当读缓存占用过多内存时，使用 LRU 等策略回收读缓存占用的内存。&lt;/p&gt;
&lt;h2 id=&#34;3-写缓冲区和写合并&#34;&gt;3 写缓冲区和写合并&lt;/h2&gt;
&lt;p&gt;​		一般默认一个写请求结束之后，所有的写入数据均已被持久化到存储设备上，也就是说在文件写入请求完成后立刻发生断电和崩溃等情况，在系统恢复后，刚刚写入的文件数据依然能够被读取到。这是一个较强但十分合理的保证。然而由于存储设备的性能较差，若每个写请求均等待写入设备完成，文件写操作的延时变长，吞吐量会严重下降，从而影响整个系统的性能。&lt;/p&gt;
&lt;p&gt;​		为了获得更好的性能，在文件系统的设计中有一个权衡：在—个文件写请求返回到应用程序之后，允许其修改的数据暂时不持久化到存储设备中。这个权衡允许文件系统暂时将修改的数据保存在内存中，并在后台慢慢地持久化到存储设备上，然而这样却牺牲了—定的可靠性。在前面的例子中，如果在文件写请求完成后立刻发生断电，再次开机之后，刚刚完成写入的数据可能会丢失。为了确保数据被持久化到设备中，POSIX 中规定了 &lt;strong&gt;fsync&lt;/strong&gt; 接口，用于保证某个已打开文件的所有修改全部被持久化到存储设备中。&lt;/p&gt;
&lt;p&gt;​		当文件系统修改完文件数据后，其修改会被暂存在写缓冲区的内存页之中。如果后续的文件请求需要读取或者修改相同存储块中的数据，文件系统可以直接在写缓冲区对应的内存页上进行读取或者修改。当可用内存不足，或者对应的 &lt;strong&gt;fsync&lt;/strong&gt; 被调用时，写缓冲区内存页中的数据才写回到存储设备对应的存储块之中。这样，一段时间内同一个存储块上的多个写请求可以合并一个磁盘写操作。&lt;/p&gt;
&lt;h2 id=&#34;4-页缓存&#34;&gt;4 页缓存&lt;/h2&gt;
&lt;p&gt;​		在Linux内核中，读缓存与写缓冲区的功能被合并起来管理，称为页缓存。页缓存以内存页为单位，将存储设备中的存储位置映射到内存中。文件系统通过调用 VFS 提供的相应接口对页缓存进行操作。&lt;/p&gt;
&lt;p&gt;​		当—个文件被读取时，文件系统会先检查其内容是否已经保存在页缓存中。如果文件数据已保存在页缓存中，则文件系统直接从页缓存中读取数据返回给应用程序；否则，文件系统会在页缓存中创建新的内存页，并从存储设备中读取相关的数据然后将其保存在创建的内存页中。之后，文件系统从内存页中读取相应的数据，返回给应用程序。&lt;/p&gt;
&lt;p&gt;​		在进行文件修改时，文件系统同样会首先检查页缓存。如果要修改的数据已经在页缓存中，文件系统可以直接修改页缓存中的数据，并将该页标记为脏页；若不在页缓存中，文件系统同样先创建页缓存并从存储没备中读取数据，然后在页缓存中进行修改并标记该页为脏页。标记为脏页的缓存会由文件系统定期写回到存储设备中。当操作系统内存不足或者应用程序调用 &lt;strong&gt;fsync&lt;/strong&gt; 时，文件系统也会将脏页中的数据写回到存储设备中。&lt;/p&gt;
&lt;h2 id=&#34;5-直接io&#34;&gt;5 直接IO&lt;/h2&gt;
&lt;p&gt;​		&lt;strong&gt;直接IO&lt;/strong&gt;就是不需要读缓冲，不需要写缓冲区和写合并。&lt;/p&gt;
&lt;p&gt;​		页缓存是持久化和性能之间权衡的产物。在大多数情况下，页缓存能够显著地提升文件系统性能。然而并非在所有情况下页缓存都能起到正面作用。一方面，部分应用对数据持久化有较强的要求，不希望文件的修改内容缓存在页缓存中。如果使用页缓存的机制，这些应用需要在每次修改文件后立即执行 &lt;strong&gt;fsync&lt;/strong&gt; 操作进行同步，这会影响应用程序的性能。另一方面，一些应用程序（如数据库等）会自己实现缓存机制对数据进行缓存和管理。由于应用程序更加了解自己对数据的需求,在这种情况下，操作系统提供的页缓存机制是冗余的，且一般会带来额外的性能开销。&lt;/p&gt;
&lt;p&gt;​		因此，文件系统将是否使用页缓存的判断和选择权交给了应用程序。应用程序可以在打开文件时通过附带 &lt;strong&gt;O_DIRECT&lt;/strong&gt; 标志，提示文件系统不要使用页缓存。这种文件访问方式就是&lt;strong&gt;直接 I/O&lt;/strong&gt; 。而相对应地，使用页缓存的文件请求称为缓存I/O。&lt;/p&gt;
&lt;h2 id=&#34;6-内存映射&#34;&gt;6 内存映射&lt;/h2&gt;
&lt;p&gt;​		除了文件的 read 和 write 接口外，应用程序还可以通过内存映射机制，以访问内存的形式访问文件内容。Linux在其页缓存的基础上实现了文件的内存映射机制。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>使用Hugo平台搭建个人博客</title>
        <link>http://ydsungan.com/p/%E4%BD%BF%E7%94%A8hugo%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
        <pubDate>Tue, 22 Mar 2022 12:44:12 +0800</pubDate>
        
        <guid>http://ydsungan.com/p/%E4%BD%BF%E7%94%A8hugo%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
        <description>&lt;h1 id=&#34;1-windows-10-安装-hugo&#34;&gt;1 Windows 10 安装 Hugo&lt;/h1&gt;
&lt;h2 id=&#34;11-安装-chocolatey-包管理器&#34;&gt;1.1 安装 Chocolatey 包管理器&lt;/h2&gt;
&lt;p&gt;windows 上需要使用 Chocolatey 作为包管理器，在安装 Hugo 之前需要在windows上安装 Chocolatey，以管理员方式运行PowerShell，输入以下指令自动安装 Chocolatey：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;Set-ExecutionPolicy&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bypass&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-Scope&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;Process&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-Force&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;[System.Net.ServicePointManager]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SecurityProtocol&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;[System.Net.ServicePointManager]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SecurityProtocol&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-bor&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;3072&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;iex &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;New-Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WebClient&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DownloadString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;https://chocolatey.org/install.ps1&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;输入命令 “choco” 来检查安装是否成功。&lt;/p&gt;
&lt;h2 id=&#34;12-安装-hugo&#34;&gt;1.2 安装 Hugo&lt;/h2&gt;
&lt;p&gt;接下来，输入以下命令来安装 Hugo：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;choco&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;install&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;hugo-extended&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-confirm&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;输入命令 “hugo help” 来检查安装是否成功。&lt;/p&gt;
&lt;h1 id=&#34;2-搭建项目&#34;&gt;2 搭建项目&lt;/h1&gt;
&lt;h2 id=&#34;21-建立项目&#34;&gt;2.1 建立项目&lt;/h2&gt;
&lt;p&gt;在 windows 的用户家目录下（C:\Users\username）输入以下命令（其中ydsungan为项目的名称）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;hugo&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;site&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ydsungan&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;22-下载主题&#34;&gt;2.2 下载主题&lt;/h2&gt;
&lt;p&gt;在【https://themes.gohugo.io/】网站选择一个主题，进入主题的 Github 页面，拷贝地址，进入项目的themes目录，克隆该主题：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cd themes
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/CaiJimmy/hugo-theme-stack.git
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;23-配置主题&#34;&gt;2.3 配置主题&lt;/h2&gt;
&lt;p&gt;在themes目录里有下载好的hugo-theme-stack文件夹，该文件夹里面的 exampleSite/config.ymal 就是配置文件，需要把该配置文件复制到项目的根目录下，直接覆盖根目录下的原有的配置文件（config.ymal 或者config.toml）。&lt;/p&gt;
&lt;p&gt;如果根目录下有 config.toml 而没有 config.ymal 文件，那么把 config.toml 直接删除即可，把 exampleSite/config.ymal 直接黏贴在项目的根目录下。&lt;/p&gt;
&lt;h2 id=&#34;24-添加内容&#34;&gt;2.4 添加内容&lt;/h2&gt;
&lt;p&gt;项目根目录下执行 &lt;em&gt;hugo new about.md&lt;/em&gt; ，会在根目录下的 content 目录下生成一个about.md文件。该文件的默认内容为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;title: &amp;#34;About&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;date: 2018-05-22T22:04:26+08:00
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;draft: true
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;draft：表示该文章是否为草稿，true表示为草稿状态，草稿状态下是对外不可见的，提交后需要改为true；&lt;/p&gt;
&lt;p&gt;不过一般的博客文章都是放在根目录下的 &lt;em&gt;/content/post/&lt;/em&gt; 目录下的，执行 &lt;em&gt;hugo new post/test.md&lt;/em&gt; 会创建一个test.md。&lt;/p&gt;
&lt;h2 id=&#34;25-启动hugo自带的服务器&#34;&gt;2.5 启动Hugo自带的服务器&lt;/h2&gt;
&lt;p&gt;使用以下命令即可启动一个Hugo服务器&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; hugo server  --theme=hugo-theme-stack
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;启动后在浏览器输入 &lt;em&gt;http://127.0.0.1:1313&lt;/em&gt; 即可。&lt;/p&gt;
&lt;h2 id=&#34;26-生成静态网页&#34;&gt;2.6 生成静态网页&lt;/h2&gt;
&lt;p&gt;使用以下命令即可在根目录下的/public/里面生成静态的HTML&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hugo --theme=hugo-theme-stack --baseUrl=&amp;#34;http://ydsungan.com&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;27-上传-github-保存&#34;&gt;2.7 上传 Github 保存&lt;/h2&gt;
&lt;p&gt;在 Github 上新建一个仓库，把整个项目上传即可。然后在自己的服务器上拉取该项目即可。&lt;/p&gt;
&lt;h2 id=&#34;28-配置自己服务器上的-nginx&#34;&gt;2.8 配置自己服务器上的 Nginx&lt;/h2&gt;
&lt;p&gt;在自己的服务器上的 Nginx 的 conf/nginx.conf 文件里面配置如下即可：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;location / {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            root   /usr/local/ydsungan_hugo/public;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            index  index.html index.htm;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;ydsungan_hugo 就是从 Github 拉取的项目，而静态HTML就生成在 public/ 目录下；输入命令 &lt;em&gt;./sbin/nginx -s reload&lt;/em&gt; 重启 nginx 即可。现在可以在浏览器访问自己的服务器了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>About</title>
        <link>http://ydsungan.com/about/</link>
        <pubDate>Tue, 22 Mar 2022 12:39:41 +0800</pubDate>
        
        <guid>http://ydsungan.com/about/</guid>
        <description>&lt;h1 id=&#34;大家好&#34;&gt;大家好&lt;/h1&gt;
&lt;p&gt;aaa&lt;/p&gt;
&lt;p&gt;大飒飒大苏打&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
