<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on ydsungan的博客</title>
        <link>http://ydsungan.com/post/</link>
        <description>Recent content in Posts on ydsungan的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sat, 16 Apr 2022 16:07:12 +0800</lastBuildDate><atom:link href="http://ydsungan.com/post/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Directory-based Protocol</title>
        <link>http://ydsungan.com/p/directory-based-protocol/</link>
        <pubDate>Sat, 16 Apr 2022 16:07:12 +0800</pubDate>
        
        <guid>http://ydsungan.com/p/directory-based-protocol/</guid>
        <description>&lt;img src="http://ydsungan.com/post/directory1.png" alt="Featured image of post Directory-based Protocol" /&gt;&lt;h2 id=&#34;snooping-based-protocol缺点&#34;&gt;Snooping-based Protocol缺点&lt;/h2&gt;
&lt;p&gt;如果有很多processor，那么总线共享，请求传播会带来总线争用，因为所有的processor都会把请求往总线上广播。这种策略适合processor较少的情况下。&lt;/p&gt;
&lt;h2 id=&#34;directory-based-protocol&#34;&gt;Directory-based Protocol&lt;/h2&gt;
&lt;p&gt;Directory-based 协议比 Snooping-based协议早产生。&lt;/p&gt;
&lt;p&gt;Directory-based 协议下，每个processor有自己的Cache、Memory、以及Directory。每一个processor可以进行点对点通信（就是直接通信），这里没有广播，没有共享的总线，没有总线争用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ydsungan.com/post/directory2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如上图所示：P1想要访问A，而A正在P3的Memory中，这时P1直接发生与P3的点对点通信，请求获取P3 Memory中的A。那么P3吧A的Copy发送给P1，P1存储在Cache中，而这时P3在自己的Directory中记下A的状态：Shared with P1。&lt;/p&gt;
&lt;p&gt;如果此时，P3也想要请求A，那么P3也会在自己的Directory中记下P3作为A的共享者。当P3想要修改A的时候，P3先检查自己的Directory，查看还有谁拥有A，它会向P1发送一条请求，让P1把Cache中的A无效（Invalidate）。而P1也会向P3发送一条确认请求，告诉P3自己已经把A无效化。这时候P3就可以放心修改A了，P3会现在自己的Directory中把 A:S_P1删除掉（因为P1中已经标记为Invalid）。&lt;/p&gt;
&lt;p&gt;当P3修改了A之后，P3将Directory中的A:S_P3修改为：A:M_P3，这个时候，P3可以使用write through和write back。&lt;/p&gt;
&lt;p&gt;然而，现在，P1中的A为无效状态，被认为是Cache Miss，称为 &lt;strong&gt;Coverage Miss&lt;/strong&gt;。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Snooping-based Protocol</title>
        <link>http://ydsungan.com/p/snooping-based-protocol/</link>
        <pubDate>Sat, 16 Apr 2022 15:15:12 +0800</pubDate>
        
        <guid>http://ydsungan.com/p/snooping-based-protocol/</guid>
        <description>&lt;h1 id=&#34;snooping-based-protocol&#34;&gt;Snooping-based Protocol&lt;/h1&gt;
&lt;p&gt;参考：https://www.youtube.com/watch?v=YNpaELJZm2c&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ydsungan.com/post/snooping1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如上图所示：有 4 个 processor，P1-P4，每个 processor 下面的方框表示私有的 Cache。此时，P1要读主存中的 A，而 P1 的 Cache（方框）为空，表示 Miss，所以它向共享的 Bus 发送一条请求，这个请求在 Bus 上广播出去，因为每个 processor 的 Cache都在监听着总线，所以每个 processor 的Cache都会知道和理解这个请求。由于其他的 processor （P2-P4）的Cache里面都没有A，所以其他的 processor 都忽略这个请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ydsungan.com/post/snooping2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，P1的Cache已经把A从主存请求过来了，这时候的P1的Cache中的A为shared状态。现在，P3也要请求主存中的A，经过同样的向总线发送请求的过程，将 A 请求到 P3 的Cache中，如下图所示，A的状态也是 Shared状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ydsungan.com/post/snooping3.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;现在，P1修改了A的值，将A修改为8，此时，P1的Cache的A的状态为Modified，【无图】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;write invalidate 策略：当P1的Cache的A的状态修改为M后，会像总线发送一条 invalidation 信号让总线上的所有的processor都将他们自己cache内的A改为invalid状态。所以P3中的A的状态修改为 I （Invalid）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Write Through：马上把Cache中的A = 8写回主存，如下图所示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Write Back：会等到下一次Cache置换的时候才把A=8写回主存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://ydsungan.com/post/snooping4.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;然而现在，P3的Cache中的A是一个无效值，认为这是一个Cache Miss，叫做 &lt;strong&gt;Coherence Miss&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;write update策略：不会像write invalidate策略那样向总线发送一条无效信号，而是发送一条更新信号，通知其他的processor去更新他们本地的Cache Copy。当所有其他的processor更新自己的cache中的A后，所有的Cache中的A的状态改为Shared，包括P1.
&lt;ul&gt;
&lt;li&gt;write through&lt;/li&gt;
&lt;li&gt;write back：均和上述相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前AMD和Intel的CPU都是采用的Snooping-based Protocol。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>LP建模5道题</title>
        <link>http://ydsungan.com/p/lp%E5%BB%BA%E6%A8%A15%E9%81%93%E9%A2%98/</link>
        <pubDate>Sat, 16 Apr 2022 15:09:12 +0800</pubDate>
        
        <guid>http://ydsungan.com/p/lp%E5%BB%BA%E6%A8%A15%E9%81%93%E9%A2%98/</guid>
        <description>&lt;h3 id=&#34;1-road-lighting-problem&#34;&gt;1 Road Lighting Problem&lt;/h3&gt;
&lt;p&gt;​		Consider a road divided into $n$ segments that is illuminated by $m$ lamps. Let $p_{j}$ be the power of the $jth$ lamp and $c$ is the cost to operate a single lamp per hour. The illumination $I_{i}$ of the $ith$ segment is assumed to be $\sum_{j=1}^ma_{ij}p_j$, where $a_{ij}$ are known coefficients. Let $I^∗_i$ be the desired illumination of segment $i$. In order to prolong the life of the lamps, each lamp needs to be turned off for one hour within 24 hours. Assume that the start and end time for the lamp to remain off are integer numbers of hours.&lt;/p&gt;
&lt;p&gt;​		We need to choosing the lamp powers $p_{j}$ and determining the turning off time for all lamps so that the illuminations $I_{i}$ meet the desired illuminations $I^∗_i$. Formulate this problem as an $ILP$ so as to minimize the cost in operating all lamps.&lt;/p&gt;
&lt;p&gt;解：&lt;/p&gt;
&lt;p&gt;​		设 $O_{hj}$ 表示第 $j$ 盏灯在第 $h$ 个小时是否开启，$O_{hj} = 1$ 表示开启了，$O_{hj} = 0$ 表示没有开启，其中$h = 1,2,&amp;hellip;,24$ , $j = 1,2,&amp;hellip;,m$ ，则目标函数为 min  $\sum_{h=1}^{24}\sum_{j=1}^mcO_{hj}$&lt;/p&gt;
&lt;p&gt;​		对于第 $j$ 盏灯，24小时之内最多只能开23个小时， 至少可以开0小时，则有：&lt;/p&gt;
&lt;p&gt;​														$\sum_{h=1}^{24}O_{hj} \leq 23$ , $j = 1,2,&amp;hellip;,m$&lt;/p&gt;
&lt;p&gt;​														$\sum_{h=1}^{24}O_{hj} \geq 0$ , $j = 1,2,&amp;hellip;,m$&lt;/p&gt;
&lt;p&gt;​		对于第 $i$ 个路段，在每个小时内都满足照明要求，则有：&lt;/p&gt;
&lt;p&gt;​														$\sum_{j=1}^{m}a_{ij}p_{j}O_{hj} \geq I^∗_i$ , $i = 1,2,&amp;hellip;,n$ , $h = 1,2,&amp;hellip;,24$&lt;/p&gt;
&lt;p&gt;​		总的有：&lt;/p&gt;
&lt;p&gt;​					min	$\sum_{h=1}^{24}\sum_{j=1}^mcO_{hj}$&lt;/p&gt;
&lt;p&gt;​					s.t.	  $\sum_{h=1}^{24}O_{hj} \leq 23$ , $j = 1,2,&amp;hellip;,m$&lt;/p&gt;
&lt;p&gt;​							   $\sum_{h=1}^{24}O_{hj} \geq 0$ , $j = 1,2,&amp;hellip;,m$&lt;/p&gt;
&lt;p&gt;​							   $\sum_{j=1}^{m}a_{ij}p_{j}O_{hj} \geq I^∗_i$ , $i = 1,2,&amp;hellip;,n$ , $h = 1,2,&amp;hellip;,24$&lt;/p&gt;
&lt;h3 id=&#34;2-profit-maximization&#34;&gt;2 Profit Maximization&lt;/h3&gt;
&lt;p&gt;​		Your factory produces three kinds of product: A, B and C. All of them need two kinds of raw materials: nickel and aluminum. The profit and cost of each kind of product are shown in the following table.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Product&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Profit($)&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Nickel(kg)&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Aluminum(kg)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;A&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;B&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;C&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;16&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;​		You only have 200 kg of nickle and 300 kg of aluminum in stock. How to arrange production to maximize profits? Please formulate this problem as a LP and transform it into dual form. Then you may solve both primal and dual problems using GLPK or Gurobi or other similar tools.&lt;/p&gt;
&lt;p&gt;解：&lt;/p&gt;
&lt;p&gt;​		设产品A、B、C分别生产 $x_{1}$、$x_{2}$、$x_{3}$ kg，则有：&lt;/p&gt;
&lt;p&gt;​		max	$10x_{1} + 8x_{2} + 16x_{3}$&lt;/p&gt;
&lt;p&gt;​		s.t.	   $3x_{1} + 3x_{2} +   2x_{3} \leq 200 $&lt;/p&gt;
&lt;p&gt;​					$4x_{1} + 3x_{2} +   7x_{3} \leq 300$&lt;/p&gt;
&lt;p&gt;​				    $x_{1} \geq 0$&lt;/p&gt;
&lt;p&gt;​					$x_{2} \geq 0$&lt;/p&gt;
&lt;p&gt;​				    $x_{3} \geq 0$&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​		对偶问题为：&lt;/p&gt;
&lt;p&gt;​		min		$200y_{1} + 300y_{2}$&lt;/p&gt;
&lt;p&gt;​		s.t.		  $3y_{1} + 4y_{2} \geq 10$&lt;/p&gt;
&lt;p&gt;​					   $3y_{1} + 3y_{2} \geq 8$&lt;/p&gt;
&lt;p&gt;​					   $2y_{1} + 7y_{2} \geq 16$&lt;/p&gt;
&lt;p&gt;​					   $y_{1},y_{2} \geq 0$&lt;/p&gt;
&lt;p&gt;​		GLPK的解：当 $x_{1} = 0, x_{2} = 53.3, x_{3} = 20$ 时，可以使利润最大化，最大利润为 746.7，具体如下图所示。&lt;/p&gt;
&lt;h3 id=&#34;3-cutting-paper-minimization&#34;&gt;3 Cutting Paper Minimization&lt;/h3&gt;
&lt;p&gt;​		Your factory has expanded its bussiness. Suppose you have an unlimited number of large rolls of paper, of width $W$ meters per roll ($W$ is a positive integer). However, different m customers demands are for smaller width of paper; in particular, customer $i$ needs $b_{i}$ rolls of paper of width $w_{i}$ , i = 1, 2, &amp;hellip;, m. We assume that $w_{i}$ ≤ W for each $i$, and each $w_{i}$ is an integer. Smaller rolls are obtained by slicing a large roll in a certain way. You can slice one roll of paper for different customers only if their total width does not exceed $W$.&lt;/p&gt;
&lt;p&gt;​		The goal of you is to minimize the number of large rolls used while satisfying customer demand. Please formulate this problem as an ILP. Assume that there is no cost for slicing.&lt;/p&gt;
&lt;p&gt;解：&lt;/p&gt;
&lt;p&gt;​		第 $i$ 个顾客需要$b_{i}$ 卷纸，所以设 $N$ 为总共需要的较小宽度卷纸数目，同时 $N$ 也是所需的完整宽度$W$的卷纸的数目的上界， $N = \sum_{i=1}^mb_{i}$ , 即在这种情况下，每个宽度较小的卷纸都是从完整卷纸里面裁切出来的。&lt;/p&gt;
&lt;p&gt;​		设$w_{j}$为$N$ 个较小宽度的卷纸中的第 $j$ 个的宽度，设变量 $y_{i}$ 代表是否使用了第 $i$ 个完整宽度的卷纸，$y_{i} = 1$表示使用了，$y_{i} = 0$ 表示没有使用，其中 $i = 1,2, &amp;hellip;, N$，设 $x_{ij}$ 代表第 $j$ 个较小宽度的卷纸是否是从第$i$ 个完整宽度的卷纸里面裁切的，$x_{ij} = 1$ 表示是，$x_{ij} = 0$ 表示否，其中 $j = 1,2, &amp;hellip;, N$。&lt;/p&gt;
&lt;p&gt;​		对于第 $i$ 个完整宽度的卷纸，所有从该卷纸里面裁切出来的小卷纸的总宽度应该小于$W$，即有：																$\sum_{j=1}^Nx_{ij}w_{j} \leq W$ , $i = 1, &amp;hellip;, N$&lt;/p&gt;
&lt;p&gt;​		对于每个较小宽度的卷纸 $j$ , 都应该被生产，它可能裁切于第 $i = 1,&amp;hellip;,N$ 个完整卷纸，即有：&lt;/p&gt;
&lt;p&gt;​																$\sum_{i=1}^Nx_{ij} = 1$ , $j = 1,&amp;hellip;,N$&lt;/p&gt;
&lt;p&gt;​		如果第 $i$ 个完整宽度的卷纸没有被使用，那么第 $j$ 个较小宽度的卷纸也不可能从中裁切出来，即有：&lt;/p&gt;
&lt;p&gt;​																$0 \leq x_{ij} \leq y_{i}, i=1,&amp;hellip;,N ,j=1,&amp;hellip;,N$&lt;/p&gt;
&lt;p&gt;​		总的有：&lt;/p&gt;
&lt;p&gt;​					min	$\sum_{i=1}^Ny_{i}$&lt;/p&gt;
&lt;p&gt;​					s.t.	 $\sum_{j=1}^Nx_{ij}w_{j} \leq W$ , $i = 1, &amp;hellip;, N$&lt;/p&gt;
&lt;p&gt;​							  $\sum_{i=1}^Nx_{ij} = 1$ , $j = 1,&amp;hellip;,N$&lt;/p&gt;
&lt;p&gt;​							  $0 \leq x_{ij} \leq y_{i}$ , $ i=1,&amp;hellip;,N ,j=1,&amp;hellip;,N$&lt;/p&gt;
&lt;p&gt;​							  $y_{i}\in {0,1}$&lt;/p&gt;
&lt;p&gt;​							  $x_{ij} \in {0,1}$&lt;/p&gt;
&lt;h3 id=&#34;4-reformulation-problems-with-absolute-values&#34;&gt;4 Reformulation Problems with Absolute Values&lt;/h3&gt;
&lt;p&gt;​		Consider the problem:&lt;/p&gt;
&lt;p&gt;​												minimize 	$2|x_{1}| + x_{2}$&lt;/p&gt;
&lt;p&gt;​												subject to    $x_{1} + x_{2} \geq 4$&lt;/p&gt;
&lt;p&gt;​		Please reformulate this problem as a LP without absolute values.&lt;/p&gt;
&lt;p&gt;解：&lt;/p&gt;
&lt;p&gt;​		minimize	$2|x_{1}| + x_{2}$ 可以写成 2·max{x~1~, -x~1~} + x~2~ ，设变量$z_{1}$，&lt;/p&gt;
&lt;p&gt;​		$z_{1} \geq x_{1}$ ,  $z_{1} \geq -x_{1}$&lt;/p&gt;
&lt;p&gt;​		可以用 z~1~ 替换|x~1~|, 则原问题可以写成：&lt;/p&gt;
&lt;p&gt;​												minimize	$2z_{1} + x_{2}$&lt;/p&gt;
&lt;p&gt;​												subject to   $x_{1} + x_{2} \geq 4$&lt;/p&gt;
&lt;p&gt;​																	 $z_{1} \geq x_{1}$&lt;/p&gt;
&lt;p&gt;​																	 $z_{1} \geq -x_{1}$&lt;/p&gt;
&lt;h3 id=&#34;5-cook-recruitment-for-ucas-canteen&#34;&gt;5 Cook Recruitment for UCAS Canteen&lt;/h3&gt;
&lt;p&gt;​		Suppose that you are the canteen manager of UCAS and you are asked to recruit a group of cooks for improving the quality of meals. It is estimated that there are $N$ stalls need to change cooks, and the $i(th)$stall needs at least $n_{i}$ cooks. The number of recruitment firms is $F$. Cooks from the $j(th)$ recruitment firm can cook different foods in several stalls $S_{j}$ and the recruitment fee for one cook from the $j(th)$ recruitment firm is $c_{j}$ . Note that $S_{j}$ is a subset of $N = {1, 2, · · · , n}$ and the union of $S_{j}$ equals to $N$.&lt;/p&gt;
&lt;p&gt;​		Your boss wants you to save money so your need to formulate this problem as an $ILP$ and your goal is minimizing the recruitment fee of enough cooks.&lt;/p&gt;
&lt;p&gt;解：&lt;/p&gt;
&lt;p&gt;​		令 $K = \sum_{i=1}^Nn_{i}$ , $K$ 表示总共需要的厨师数量的上界。&lt;/p&gt;
&lt;p&gt;​		就设一共有 $K$ 个厨师，$x_{l}$ 表示第 $l$ 个厨师是否被录用，$x_l = 1$ 表示被录用，$x_l = 0$ 表示没有被录用；$y_{lj}$ 表示第 $l$ 个厨师是否是第 $j$ 家公司的，$y_{lj} = 1$ 表示属于，$y_{lj} = 0$ 表示不属于；则目标函数为 min $\sum_{l=1}^K\sum_{j=1}^Fx_{l}y_{lj}c_{j}$ .&lt;/p&gt;
&lt;p&gt;​		由于第 $i$ 个摊位需要 $n_{i}$ 个厨师，设 $z_{lji}$ 表示第 $l$ 位来自第 $j$ 家公司的厨师是否去了第 $i$ 个摊位，$z_{lji} = 1$ 表示去了，$z_{lji} = 0$ 表示没去，则有：&lt;/p&gt;
&lt;p&gt;​														$\sum_{l=1}^{K}x_lz_{lji} = n_{i}$ , $i = 1,2,&amp;hellip;,N$&lt;/p&gt;
&lt;p&gt;​		由于第 $j$ 个公司的厨师可以同时为 $S_{j}$ 个摊位服务，每个厨师所服务的摊位数都不大于 $S_{j}$，则有：&lt;/p&gt;
&lt;p&gt;​													   $\sum_{i=1}^Nx_{l}y_{lj}z_{lji} \leq S_{j}$ , $j = 1,2,&amp;hellip;,m$ , $l = 1,2,&amp;hellip;,K$&lt;/p&gt;
&lt;p&gt;​		总的有：&lt;/p&gt;
&lt;p&gt;​					min	$\sum_{l=1}^K\sum_{j=1}^Fx_{l}y_{lj}c_{j}$&lt;/p&gt;
&lt;p&gt;​					s.t.	 $\sum_{l=1}^{K}x_lz_{lji} = n_{i}$ , $i = 1,2,&amp;hellip;,N$&lt;/p&gt;
&lt;p&gt;​							  $\sum_{i=1}^Nx_{l}y_{lj}z_{lji} \leq S_{j}$ , $j = 1,2,&amp;hellip;,m$ , $l = 1,2,&amp;hellip;,K$&lt;/p&gt;
&lt;p&gt;​							  $x_{l} \geq y_{lj} \geq z_{lji}$ , $\forall l,j,i$&lt;/p&gt;
&lt;p&gt;​							 $x_{l}\in {0,1}$&lt;/p&gt;
&lt;p&gt;​							 $y_{lj}\in {0,1}$&lt;/p&gt;
&lt;p&gt;​							 $z_{lji}\in {0,1}$&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
        </item>
        <item>
        <title>DC算法6道题</title>
        <link>http://ydsungan.com/p/dc%E7%AE%97%E6%B3%956%E9%81%93%E9%A2%98/</link>
        <pubDate>Sat, 16 Apr 2022 15:06:12 +0800</pubDate>
        
        <guid>http://ydsungan.com/p/dc%E7%AE%97%E6%B3%956%E9%81%93%E9%A2%98/</guid>
        <description>&lt;h3 id=&#34;1-divide-and-conquer&#34;&gt;1 Divide and Conquer&lt;/h3&gt;
&lt;p&gt;​		Given an integer array numbers and an integer k, please return the k-th largest element in the array.
​		Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(logn), prove the correctness and analyze the complexity.(k is much smaller than n, n is the length of the array.)&lt;/p&gt;
&lt;p&gt;(1) Describe algorithm in natural language&lt;/p&gt;
&lt;p&gt;​		本题的解决方法是在快速排序的基础上做出选择。对数组A[l&amp;hellip;r]做快速排序的过程是：首先从数组中选择一个元素x作为主元，将数组A[l&amp;hellip;r]划分成俩个子数组A[l&amp;hellip;q-1]、A[q+1&amp;hellip;r]，使得A[l&amp;hellip;q-1]中的每一个元素都小于A[q]，且A[q]小于A[q+1&amp;hellip;r]中的每一个元素，x的最终位置就是q；然后通过递归调用快速排序对子数组A[l&amp;hellip;q-1]、A[q+1&amp;hellip;r]进行排序；因为子数组都是原地址排序的，所以不需要合并操作。&lt;/p&gt;
&lt;p&gt;​		每次划分操作后，可以确定一个元素的最终位置，所以如果某次划分操作后的q为倒数第k个下标后，则返回A[q]，否则，如果q小于倒数第k个下标，就递归右边的子数组，否则递归左边的子数组，将原来递归俩个子数组变成了只递归一个子数组。&lt;/p&gt;
&lt;p&gt;(2) Pseudo-code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function findKthLargest(A, l, r, k1) //k1 = n - k, n is the lenth of A
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: q = partition(A, l, r)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2: if q == k1 then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3:     return A[k1];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4: else if q &amp;lt; k1 then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5:     return findKthLargest(A, q+1, r, k1)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6: else
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7:     return findKthLargest(A, l, q-1, k1)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8: end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function partition(A, l, r)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: Choose an index x from [l,r] at random and use A[x] as pivot
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2: Swap A[x] with A[r]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3: pivot = A[r]; i = l;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4: for j = l to r - 1 do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5:     if A[j] &amp;lt; pivot then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6:         Swap A[i] with A[j];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7:         i ++;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8:     end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;9: end for
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10:Swap A[i] with A[r];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:return i;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(4) Prove the correctness of algorithm&lt;/p&gt;
&lt;p&gt;​		上述算法采用基于快速排序的选择方法。对于数组A[l,r]，每次选择一个元素作为pivot，设pivot下标为q，划分为俩个数组A[l, q-1]和A[q+1, r]，使得数组A[l, q-1]中的每一个元素都小于pivot，数组A[q+1, r]中的每一个元素都大于pivot，每经过一次划分数组，pivot元素的位置都是可以最终确定的，所以有以下三种情况：&lt;/p&gt;
&lt;p&gt;​		若pivot的下标q = n - k，其中n是A数组的长度，则返回A[q]，A[q]即为答案；&lt;/p&gt;
&lt;p&gt;​		若pivot的下标q &amp;lt; n - k，就对右子区间[q+1, r]实行递归调用；&lt;/p&gt;
&lt;p&gt;​		若pivot的下标q &amp;gt; n - k，就对左子区间[l, q-1]实行递归调用；&lt;/p&gt;
&lt;p&gt;​		因此，基于快速排序的选择方法必能找到第k大的数字。&lt;/p&gt;
&lt;p&gt;(5) Analyze the complexity of algorithm&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最坏时间复杂度&lt;/p&gt;
&lt;p&gt;若每次选择的都是数组中最大或者最小的元素，则有T(n) &amp;lt;= T(n-1) + cn，则复杂度为O(n^2)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最好时间复杂度&lt;/p&gt;
&lt;p&gt;若每次选择的为中间的元素，则有T(n) &amp;lt;= T(n/2) + cn，则时间复杂度为O(n)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均时间复杂度&lt;/p&gt;
&lt;p&gt;O(n)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-divide-and-conquer&#34;&gt;2 Divide and Conquer&lt;/h3&gt;
&lt;p&gt;​		Consider an n-node complete binary tree T, where n = 2^d − 1 for some d. Each node v of T is labeled with a real number Xv. You may assume that the real numbers labeling the nodes are all distinct. A node v of T is a local minimum if the label Xv is less than the label Xw for all nodes w that are joined to v by an edge.&lt;/p&gt;
&lt;p&gt;​		You are given such a complete binary tree T, but the labeling is only specified in the following:&lt;/p&gt;
&lt;p&gt;​		implicit way: for each node v, you can determine the value Xv by probing the node v.&lt;/p&gt;
&lt;p&gt;​		Show how to find a local minimum of T using only O(logn) probes to the nodes of T.&lt;/p&gt;
&lt;p&gt;(1) Describe algorithm in natural language&lt;/p&gt;
&lt;p&gt;​		从二叉树的根节点出发，如果根节点的左右子节点的值均大于根节点的值，则返回根节点的值，否则至少有一个子节点的值小于其值。选择拥有较小值的子节点作为根节点递归。&lt;/p&gt;
&lt;p&gt;(2) Pseudo-code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function findLocalMinNode(root)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: if root == NIL then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2:     return;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3: end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4: if root.lchild != NIL and root.rchild != NIL then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5:     if root.val &amp;lt; root.lchild.val and root.val &amp;lt; root.rchild.val then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6:         return root.val;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7:     else if root.lchild.val &amp;lt; root.rchild.val then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8:         findLocalMinNode(root.lchild);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;9:     else then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10:        findLocalMinNode(root.rchild);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:    end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;12:else then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;13:    return root.val;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;14:end if
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(4) Prove the correctness of algorithm&lt;/p&gt;
&lt;p&gt;​		在上述算法过程中，从完全二叉树的根节点开始遍历，如果根节点的值小于俩个子节点的值，则根节点就是一个局部最小值点，返回根节点的值即可。否则，至少存在一个子节点的值小于根节点，将较小值的子节点作为根节点递归即可，这样一定能找到一个局部最小值。最坏的情况是遍历到叶节点，叶节点只其父节点与其相连，父节点的值大于叶节点的值，则该叶节点就是局部最小值。&lt;/p&gt;
&lt;p&gt;(5) Analyze the complexity of algorithm&lt;/p&gt;
&lt;p&gt;​		时间复杂度为O(logn)&lt;/p&gt;
&lt;h3 id=&#34;3-divide-and-conquer&#34;&gt;3 Divide and Conquer&lt;/h3&gt;
&lt;p&gt;​		Given an integer array, one or more consecutive integers in the array form a sub-array. Find the maximum value of the sum of all sub-array.
​		Please give an algorithm with O(nlogn) complexity.&lt;/p&gt;
&lt;p&gt;(1) Describe algorithm in natural language&lt;/p&gt;
&lt;p&gt;​		将区间[l,r]划分为左区间[l,mid]和右区间[mid+1,r]，对左右子区间分治求解，当递归到区间长度为1的时候，这时需要将左区间[l,mid]的信息和右区间[mid+1,r]的信息合并成区间[l,r]的信息。&lt;/p&gt;
&lt;p&gt;​		对于一个区间[l,r]，需要维护的变量有：lSum表示[l,r]内以l为左端点的最大子序列和，rSum表示[l,r]内以r为右端点的最大子序列和，mSum表示[l,r]内的最大子序列和，iSum表示[l,r]的区间和。将左右子区间的信息合并到[l,r]按照以下方式：&lt;/p&gt;
&lt;p&gt;​		[l,r]区间的iSum就等于左区间的iSum加上右区间的iSum;&lt;/p&gt;
&lt;p&gt;​		[l,r]区间的lSum就等于左区间的lSum和左区间的iSum加上右区间的lSum俩者的最大值；&lt;/p&gt;
&lt;p&gt;​		[l,r]区间的rSum就等于右区间的rSum和右区间的iSum加上左区间的rSum俩者的最大值；&lt;/p&gt;
&lt;p&gt;​		[l,r]区间的mSum取左区间的mSum，右区间的mSum，左区间的rSum加上右区间的lSum三者的最大值；&lt;/p&gt;
&lt;p&gt;​		而对于长度为1的区间[i,i]上面4个值都等于A[i]，最终所求的mSum就是答案；&lt;/p&gt;
&lt;p&gt;(2) Pseudo-code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function maxSubArraySum(A, l, r)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: if l == r then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2:     return {A[r], A[r], A[r], A[r]}; //返回数组中的元素从左到右分别是iSum,lSum,rSum,mSum
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3: end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4: mid = ⌊(l+r)/2⌋
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5: lSub = maxSubArraySum(A, l, mid);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6: rSub = maxSubArraySum(A, mid+1, r);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7: iSum = lSub[0] + rSub[0];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8: lSum = max{lSub[1], lSub[0]+rSub[1]};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;9: rSum = max{rSub[2], rSub[0]+lSub[2]};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10:mSum = max{lSub[3], rSub[3], lSub[2]+rSub[1]};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:return {iSum, lSum, rSum, mSum}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(4) Prove the correctness of algorithm&lt;/p&gt;
&lt;p&gt;​		本题采用分治解法。对于一个区间[l, r]，取 mid = ⌊(l+r)/2⌋，划分成俩个区间 [l, mid] 和 [mid+1, r]，同样对这俩个区间递归划分，直到区间的长度为1的时候，开始合并区间的信息。对于一个区间[l, r]需要维护的变量有4个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lSum 表示 [l,r] 内以 l 为左端点的最大子序列和&lt;/li&gt;
&lt;li&gt;rSum 表示 [l,r] 内以 r 为右端点的最大子序列和&lt;/li&gt;
&lt;li&gt;mSum 表示 [l,r] 内的最大子序列和&lt;/li&gt;
&lt;li&gt;iSum 表示 [l,r] 内所有元素的和&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于长度为1的区间[i,i]，以上4个变量相等，为A[i]；对于合并后长度大于1的区间，上述4个变量更新的方式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[l,r]区间的iSum就等于左区间的iSum加上右区间的iSum;&lt;/li&gt;
&lt;li&gt;[l,r]区间的lSum就等于左区间的lSum和左区间的iSum加上右区间的lSum俩者的最大值；&lt;/li&gt;
&lt;li&gt;[l,r]区间的rSum就等于右区间的rSum和右区间的iSum加上左区间的rSum俩者的最大值；&lt;/li&gt;
&lt;li&gt;[l,r]区间的mSum取左区间的mSum，右区间的mSum，左区间的rSum加上右区间的lSum三者的最大值；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终的mSum就是整个区间的最大的子序列的和。&lt;/p&gt;
&lt;p&gt;(5) Analyze the complexity of algorithm&lt;/p&gt;
&lt;p&gt;​		时间复杂度为O(n)。&lt;/p&gt;
&lt;h3 id=&#34;4-divide-and-conquer&#34;&gt;4 Divide and Conquer&lt;/h3&gt;
&lt;p&gt;​		Given an array of integers numbers sorted in ascending order, find the starting and ending position of a given target value. If the target is not found in the array, return [-1, -1]. For example, if the array is [5, 7, 7, 8, 8, 10] and the target is 8, then the output should be [3, 4].
​		Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n), prove the correctness and analyze the complexity.&lt;/p&gt;
&lt;p&gt;(1) Describe algorithm in natural language&lt;/p&gt;
&lt;p&gt;​		本题的解决方式为使用二分查找。需要寻找数组中第一个等于target的位置和最后一个等于target的位置。&lt;/p&gt;
&lt;p&gt;​		二分查找第一个等于target的位置：当A[mid] &amp;gt;= target时，往左半区间寻找，r = mid；当A[mid] &amp;lt; target时，往右半区间查找，l = mid + 1；当l = r二分查找结束，如果A[r] != target说明数组中不存在target，返回[-1, -1]。&lt;/p&gt;
&lt;p&gt;​		二分查找最后一个等于target的位置：当A[mid]&amp;lt;=target时，往右半区间查找，l = mid；当A[mid] &amp;gt; target时，往左半区间查找，r = mid - 1；当l = r二分查找结束，此时的r就是第二次二分查找的位置，返回区间即可。&lt;/p&gt;
&lt;p&gt;(2) Pseudo-code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function binarySearch(A, n, target)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: if n == 0 then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2:     return {-1, -1};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3: end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4: l = 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5: r = n - 1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6: while l &amp;lt; r do //二分查找开始位置
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7:     mid = ⌊(l+r)/2⌋
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8:     if A[mid] &amp;gt;= target then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;9:         r = mid;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10:    else
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:        l = mid + 1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;12:    end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;13:end while
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;14:if A[r] != target then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;15:    return {-1, -1};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;16:end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;17:L = r;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;18:l = 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:r = n - 1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;20:while l &amp;lt; r do //二分查找结束位置
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;21:    mid = ⌊(l+r+1)/2⌋
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;22:    if A[mid] &amp;lt;= target then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;23:        l = mid;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;24:    else
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;25:        r = mid - 1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;26:    end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;27:end while
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;28:return {L,r};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(4) Prove the correctness of algorithm&lt;/p&gt;
&lt;p&gt;​		本题采用二分查找的方式。需要查找目标值target第一次出现的位置和最后一次出现的位置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找目标值第一次出现的位置：取mid = ⌊(l+r)/2⌋，将区间[l,r]划分成俩个区间[l,mid]和[mid+1,r]
&lt;ul&gt;
&lt;li&gt;当 A[mid] &amp;gt;= target，往左半区间查找，r = mid;&lt;/li&gt;
&lt;li&gt;当 A[mid] &amp;lt; target，往右半区间查找，l = mid + 1;&lt;/li&gt;
&lt;li&gt;当 l = r，二分查找结束，如果A[r] != target，说明数组中不存在目标值target，返回[-1, -1]。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;查找目标值最后一次出现的位置：取mid = ⌊(l+r+1)/2⌋，将区间[l,r]划分成俩个区间[l,mid-1]和[mid,r]
&lt;ul&gt;
&lt;li&gt;当 A[mid] &amp;lt;= target，往右半区间查找，l = mid;&lt;/li&gt;
&lt;li&gt;当 A[mid] &amp;gt; target，往左半区间查找，r = mid - 1;&lt;/li&gt;
&lt;li&gt;当 l = r，二分查找结束，r就是目标值最后一次出现的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，采用俩次二分查找可以找到目标值的开始出现位置和最后出现位置。&lt;/p&gt;
&lt;p&gt;(5) Analyze the complexity of algorithm&lt;/p&gt;
&lt;p&gt;​		时间复杂度：O(log n) ，其中 n 为数组的长度。二分查找的时间复杂度为O(log n)，一共会执行两次，因此总时间复杂度为O(log n)。&lt;/p&gt;
&lt;h3 id=&#34;5-divide-and-conquer&#34;&gt;5 Divide and Conquer&lt;/h3&gt;
&lt;p&gt;​		Given a convex polygon with n vertices, we can divide it into several separated pieces, such that every piece is a triangle. When n = 4, there are two different ways to divide the polygon; When n = 5, there are five different ways.
​		Give an algorithm that decides how many ways we can divide a convex polygon with n vertices into triangles.&lt;/p&gt;
&lt;p&gt;(1) Describe algorithm in natural language&lt;/p&gt;
&lt;p&gt;​		一般 n 个顶点的凸多边形可以分成 m = n - 2 个三角形。&lt;/p&gt;
&lt;p&gt;​		将n个顶点的凸多边形的顶点依次序标记为P1、P2、P3、&amp;hellip;、Pn， 凸多边形的任意一条边必属于某一个三角形，以这条边为基准，设这条边的俩个顶点分别是P1、Pn，然后在凸多边形中找一个任意不属于该边的顶点Pk，（2&amp;lt;=k&amp;lt;=n-1），组成一个三角形，这个三角形将原来的凸多边形分割成俩个凸多边形，其中一个凸多边形的顶点数目为n-k+1，另一个凸多边形的顶点数目k；&lt;/p&gt;
&lt;p&gt;​		则 f(n) 的解由 f(n-k+1) 和 f(k) 组成，f(n) = f(n-k+1) * f(k)，而 2&amp;lt;=k&amp;lt;=n-1，所以原式可以分解为 ：f(n) = f(n-1) * f(2) + f(n-2) * f(3) + &amp;hellip; + f(2) * f(n-1)，另外f(2) = f(3) = 1，f(2)表示这个三角形只将原凸多边形分割成一个凸多边形，可以认为f(2) = 1。这样就把 f(n) 问题的求解分成一个个子问题的求解，直到子问题的规模为n = 2或者n = 3。&lt;/p&gt;
&lt;p&gt;(2) Pseudo-code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function divideConvexPolygon(n)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: initialize an array A with size of n + 1, and assign a value of 0 to each element;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2: A[2] = A[3] = 1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3: return subProblem(A, n);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function subProblem(A, n)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: if A[n] != 0 then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2:     return A[n];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3: end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4: sum = 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5: for k = 2 to n - 1 do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6:     if A[k] == 0 then    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7:         A[k] = subProblem(A, k);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8:     end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;9:     if A[n-k+1] == 0 then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10:        A[n-k+1] = subProblem(A, n-k+1);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:    end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;12:    sum += A[k] * A[n-k+1];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;13:end for
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;14:A[n] = sum;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;15:return A[n];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(4) Prove the correctness of algorithm&lt;/p&gt;
&lt;p&gt;​		本算法采用自顶向下的带记忆的递归解法。具有n个顶点的凸多边形的任意一条边必属于某一个三角形，那么以这条边为基准，然后在凸多边形中找一个任意不属于这条边上的顶点，组成一个三角形，这个三角形会将原凸多边形分割成俩个小的凸多边形（也可能只有一个小的凸多边形），这样就将大问题的解分解成俩个小问题的解，同样对于小凸多边形以同样的方法将其分解为更小的凸多边形。&lt;/p&gt;
&lt;p&gt;​		假设凸多边形的n个顶点依次按序标记为P1、P2、P3、&amp;hellip;、Pn，以P1-Pn作为基准边，任意选择一个不属于该边的顶点Pk，（2&amp;lt;=k&amp;lt;=n-1），组成的三角形将原凸多边形分割成俩个小的凸多边形，则f(n)的解由 f(n-k+1) 和 f(k) 组成，f(n) = f(n-k+1) * f(k)，k有n-2种选择，所以原式可以分解为 ：f(n) = f(n-1) * f(2) + f(n-2) * f(3) + &amp;hellip; + f(2) * f(n-1)，这样子问题递归分解下去直到遇到f(2)和f(3)不再分解，f(2) = f(3) = 1。所以这样自顶向下的递归分解子问题最终一定能求出f(n)的问题。&lt;/p&gt;
&lt;p&gt;(5) Analyze the complexity of algorithm&lt;/p&gt;
&lt;p&gt;​		由于该算法设置了一个数组A去记录每一步计算中产生的f(k)的子问题的解，避免f(k)子问题的重复计算，子问题就是f(2)，f(3)，&amp;hellip;，f(n)，所以本算法的时间复杂度为O(n)。&lt;/p&gt;
&lt;h3 id=&#34;6-divide-and-conquer&#34;&gt;6 Divide and Conquer&lt;/h3&gt;
&lt;p&gt;​		Given an array of k linked-lists lists, each linked-list is sorted in ascending order. Given an O(knlogk) algorithm to merge all the linked-lists into one sorted linked-list. (Note that the length of a linked-lists is n)&lt;/p&gt;
&lt;p&gt;(1) Describe algorithm in natural language&lt;/p&gt;
&lt;p&gt;​		将 k 个链表俩俩一组，共有 k/2 组，每一组俩个链表合并成一个链表，得到 k/2 个链表；将 k/2 个链表俩俩一组，共有 k/4 组，每一组俩个链表合并成一个链表，得到 k/4 个链表；依此类推，最终得到合并的结果。&lt;/p&gt;
&lt;p&gt;(2) Pseudo-code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function mergeKLists(A, l, r)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: while l &amp;lt; r do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2:     mid = ⌊(l+r)/2⌋
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3:     return merge(mergeKLists(A, l, mid), mergeKLists(A, mid+1, r));
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4: end while
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5: return A[l];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function merge(L1, L2)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: a = L1, b = L2;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2: initialize two list node: head, tail;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3: tail = head;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4: while a != NIL &amp;amp;&amp;amp; b != NIL do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5:     if a.val &amp;lt; b.val then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6:         tail.next = a;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7:         a = a.next;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8:     else then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;9:         tail.next = b;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10:        b = b.next;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:    end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;12:    tail = tail.next
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;13:end while
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;14:tail.next = a ? a : b;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;15:return head.next;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(4) Prove the correctness of algorithm&lt;/p&gt;
&lt;p&gt;​		将 k 个链表俩俩一组，共有 k/2 组，每一组俩个链表合并成一个链表，得到 k/2 个链表；将 k/2 个链表俩俩一组，共有 k/4 组，每一组俩个链表合并成一个链表，得到 k/4 个链表；依此类推，最终得到合并的结果。&lt;/p&gt;
&lt;p&gt;(5) Analyze the complexity of algorithm&lt;/p&gt;
&lt;p&gt;​		俩个长度均为n的升序链表的合并的时间复杂度为O(2n)，第一轮合并时有 k/2 组，每组的时间复杂度为O(2n)，则第一轮合并的总的时间复杂度为O(kn)；第二轮合并时有 k/4 组，每组的时间复杂度为O(4n)，则第二轮合并的总的时间复杂度为O(kn)；一共logk次合并，则总的时间复杂度为O(knlogk)。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>DP算法5道题</title>
        <link>http://ydsungan.com/p/dp%E7%AE%97%E6%B3%955%E9%81%93%E9%A2%98/</link>
        <pubDate>Sat, 16 Apr 2022 15:06:12 +0800</pubDate>
        
        <guid>http://ydsungan.com/p/dp%E7%AE%97%E6%B3%955%E9%81%93%E9%A2%98/</guid>
        <description>&lt;h3 id=&#34;1-money-robbing&#34;&gt;1 Money robbing&lt;/h3&gt;
&lt;p&gt;​		A robber is planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;
&lt;p&gt;(1) Describe the optimal substructure and DP equation&lt;/p&gt;
&lt;p&gt;设列表 nums 表示每个房间的现金，设数组 dp 中元素 dp[i] 表示在第 0 ~ i 间房子可偷窃的最大金额，有状态转移方程：&lt;/p&gt;
&lt;p&gt;​										dp[i] = max(dp[i-2] + nums[i], dp[i-1])&lt;/p&gt;
&lt;p&gt;(2) Describe your algorithm in pseudo-code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function rob(nums)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: if nums == NIL or nums.length == 0 then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2:     return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3: end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4: if nums.length == 1 then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5:     return nums[0];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6: end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7: initialize an array dp with size of nums.length;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8: dp[0] = nums[0];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;9: dp[1] = max(nums[0], nums[1]);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10:for i = 2 to nums.length -1 do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:    dp[i] = max(dp[i - 2] + nums[i], dp[i-1]);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;12:end for
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;13:return dp[nums.length - 1]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(3) Prove the correctness of your algorithm&lt;/p&gt;
&lt;p&gt;本题采用动态规划的方法来解题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定 dp 数组以及含义：设 dp[i] 表示第 0~i 间房子可偷窃的最大现金，dp数组的大小为房间的个数；&lt;/li&gt;
&lt;li&gt;确定基础解：如果只有一间房子，则 dp[0] = nums[0]，如果有俩间房子，偷盗其中现金多的一间房子，则 dp[1] = max(nums[0], nums[1])，对于 2 &amp;lt;= i &amp;lt; nums.length，dp[i] 无需初始化；&lt;/li&gt;
&lt;li&gt;确定状态转移方程：对于第 i 间房子（i &amp;gt;= 2，i 从0开始），有俩个选择，即要么偷盗第 i 间房子，那么就无法偷盗第 i - 1 间房子，这时可以偷盗的最大价值为 dp[i] = dp[i - 2] + nums[i]；要么不偷盗第 i 间房子，可偷盗的最大价值为前 i - 1 间房子的最大价值 dp[i] = dp[i - 1]；则有状态转移方程 dp[i] = max(dp[i - 2] + nums[i], dp[i-1])。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样，计算到 dp[nums.length - 1] 即表示结果。&lt;/p&gt;
&lt;p&gt;(4) Analyze the complexity of your algorithm&lt;/p&gt;
&lt;p&gt;本题算法只需要对 dp 数组遍历一遍即可，时间复杂度为 O(n)，其中n是dp数组的长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What if all houses are arranged in a circle?&lt;/p&gt;
&lt;p&gt;(1) Describe the optimal substructure and DP equation&lt;/p&gt;
&lt;p&gt;设列表 nums 表示每个房间的现金，设数组 dp 中元素 dp[i] 表示在第 start ~ i 间房子可偷窃的最大金额，有状态转移方程：&lt;/p&gt;
&lt;p&gt;​										dp[i] = max(dp[i-2] + nums[i], dp[i-1])&lt;/p&gt;
&lt;p&gt;(2) Describe your algorithm in pseudo-code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function rob(nums)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: len = nums.length;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2: if len == 1 then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3:     return nums[0];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4: else if len == 2 then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5:     return max(nums[0],nums[1]);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6: end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7: initialize an array dp with size of len;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8: dp[0] = nums[0];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;9: dp[1] = max(nums[0],nums[1]);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10:for i = 2 to len - 1 do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:    dp[i] = max(dp[i-1], nums[i] + dp[i-2]);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;12:end for
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;13:if nums[1] &amp;gt;= nums[0] and dp[2] != dp[1] or nums[1] &amp;lt; nums[0] then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;14:    dp[len - 1] = min(dp[len - 1], dp[len - 2]);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;15:end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;16:m = dp[len - 1];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;17:dp[1] = nums[1];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;18:dp[2] = max(nums[1],nums[2]);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:for i = 3 to len - 1 do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;20:    dp[i] = max(dp[i-1], nums[i] + dp[i-2]);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;21:end for
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;22:n = dp[len - 1];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;23:return max(m,n);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(3) Prove the correctness of your algorithm&lt;/p&gt;
&lt;p&gt;如果只有一间房屋，则可以偷窃该房子；如果有俩间房子，只能偷窃一间房子，则偷窃现金多的一间房子。当房屋的数量多于2间需要考虑首位相连的情况。&lt;/p&gt;
&lt;p&gt;需要考虑到不能同时偷窃第一间和最后一间房子，如果偷窃了第一间房子则不能偷窃最后一间，如果没有偷窃第一间，则可以偷窃最后一间房子。首先在第一问的基础上计算得到 dp[0, 1, &amp;hellip;, n-1] 的所有元素，在此基础上判断第一间房子是否被偷窃，如果第一间房子被偷窃了，那么最后一间房子不能被偷窃了，则有 dp[n - 1] = dp[n - 2]；然后选择不偷窃第一间房子，那么最后一间房子就可以被偷窃了，重新选择区间按照第一问的状态转移公式再计算一遍。&lt;/p&gt;
&lt;p&gt;所以本题算法需要执行俩次状态转移公式的过程。第一次执行时的基础解为 dp[0] = nums[0], dp[1] = max(nums[0], nums[1])；第二次执行时的基础解为 dp[1] = nums[1], dp[2] = max(nums[1], nums[2])。第一次执行完成过后需要检查一遍第一间房子有没有被盗窃，如果第一间被盗窃了，再检查一遍最后一件房子有没有被盗窃，如果最后一间房子被盗窃了，则修改 dp[n - 1] = dp[n - 2]；而执行完第二遍公式后，不需要检查。最后比较俩次的最终的dp[n-1]结果，返回值大的即可。&lt;/p&gt;
&lt;p&gt;(4) Analyze the complexity of your algorithm&lt;/p&gt;
&lt;p&gt;对dp数组遍历了2次，所以时间复杂度为O(n)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2--largest-divisible-subset&#34;&gt;2  Largest Divisible Subset&lt;/h3&gt;
&lt;p&gt;​		Given a set of distinct positive integers, find the largest subset such that every pair (S~i~ , S~j~ ) of elements in this subset satisfies: S~i~%S~j~ = 0 or S~j~%S~i~ = 0.&lt;/p&gt;
&lt;p&gt;​		Please return the largest size of the subset.&lt;/p&gt;
&lt;p&gt;​		Note: S~i~%S~j~ = 0 means that S~i~ is divisible by S~j~&lt;/p&gt;
&lt;p&gt;(1) Describe the optimal substructure and DP equation&lt;/p&gt;
&lt;p&gt;dp[i] 表示数组 nums 中下标从 0 到 i 的序列中包含 nums[i] 的最大整除子序列的长度，dp数组的长度等于nums数组的长度，且其中的每一个元素都被初始化为1，对于每一个 nums[i]，需要检查 [0, i-1] 区间上的每一位nums[j]，使得 nums[i] % nums[j] == 0，有状态转移方程：&lt;/p&gt;
&lt;p&gt;​														dp[i] = max(dp[i], dp[j] + 1)&lt;/p&gt;
&lt;p&gt;(2) Describe your algorithm in pseudo-code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function largestDivisibleSubset(nums)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: len = nums.length;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2: initialize an array dp with size of len and assign a value of 1 to each element;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3: sort(nums);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4: for i = 1 to len - 1 do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5:     for j = 0 to i - 1 do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6:         if nums[i] % nums[j] == 0 then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7:             dp[i] = max(dp[i], dp[j]+1);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8:         end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;9:     end for
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10:end for
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:return max(dp);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(3) Prove the correctness of your algorithm&lt;/p&gt;
&lt;p&gt;首先将数组nums进行升序排列，这样如果 nums[j] 可以整除 nums[k]，而nums[l]可以整除nums[j]，则nums[l]也可以整除nums[k]。dp[i] 表示 nums数组中下标 0 ~ i 的序列里包含 nums[i] 的最长整除子序列的长度，在计算 dp[i]的过程中，需要枚举 j = 0, 1, &amp;hellip;, i-1的所有数nums[j]，如果 nums[i] 可以整除 nums[j]，说明nums[i] 可以扩充在以 nums[j] 为最大整数的整除子集里成为一个更大的整除子集，这时在下标 0 ~ i 的区间一个可能的最大的整除序列的长度就是 dp[j] + 1，如果dp[j] + 1大于自身dp[i]，则更新。这样就能求出最终的值。&lt;/p&gt;
&lt;p&gt;(4) Analyze the complexity of your algorithm&lt;/p&gt;
&lt;p&gt;对数组排序的时间复杂度为O(nlogn)，计算dp数组的时间复杂度为O(n^2^)，所以总的时间复杂度为O(n^2^)。&lt;/p&gt;
&lt;h3 id=&#34;5-distinct-sequences&#34;&gt;5 Distinct Sequences&lt;/h3&gt;
&lt;p&gt;​		Given two strings S and T, return the number of distinct subsequences of S which equals T.
​		A string’s subsequence is a new string formed from the original string by deleting some (can
be none) of the characters without disturbing the remaining characters’ relative positions. (i.e.,
”ACE” is a subsequence of ”ABCDE” while ”AEC” is not).&lt;/p&gt;
&lt;p&gt;(1) Describe the optimal substructure and DP equation&lt;/p&gt;
&lt;p&gt;dp[i] [j]表示字符串S的第 1 ~ i个字符组成的子串中以S[i]结尾的子序列中由字符串 T 的第 1~ j 个字符组成的子串出现的个数，并认为一个空字符串是任何字符串的子序列。有状态转移方程：当 t[j-1] == s[i-1] 时，有 dp[i] [j] = dp[i-1] [j-1] + dp[i-1] [j]；当 t[j-1] != s[i-1] 时，有 dp[i] [j] = dp[i-1] [j]。&lt;/p&gt;
&lt;p&gt;(2) Describe your algorithm in pseudo-code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function distinctSequences(S, T)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: m = S.length;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2: n = T.length;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3: if n &amp;lt; m then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4:     return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5: end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6: define a two-dimensional array dp[m+1][n+1] and assign a value of 0 to each element;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7: for i = 0 to m do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8:     dp[i][0] = 1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;9: end for
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10:for i = 1 to m do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:    for j = 1 to n do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;12:        if t[j-1] == s[i-1] then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;13:            dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;14:        else then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;15:            dp[i][j] = dp[i-1][j];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;16:        end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;17:    end for
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;18:end for
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:return dp[m][n];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(3) Prove the correctness of your algorithm&lt;/p&gt;
&lt;p&gt;首先确定dp数组的下标的含义，dp[i] [j] 表示字符串S的第 1 ~ i个字符组成的子串中以S[i]结尾的子序列中由字符串 T 的第 1~ j 个字符组成的子串出现的个数，并认为一个空字符串是任何字符串的子序列。在依次枚举每个字符时，如果 S[i - 1] 与 T[j - 1]相等，dp[i] [j]可以有两部分组成：一部分是用S[i - 1]来匹配，那么个数为dp[i - 1] [j - 1]，一部分是不用S[i - 1]来匹配，个数为dp[i - 1] [j]，所以当S[i - 1] 与 T[j - 1]相等时，dp[i] [j] = dp[i - 1] [j - 1] + dp[i - 1] [j]；如果S[i - 1] 与 T[j - 1]不相等时，dp[i] [j]只有一部分组成，不用S[i - 1]来匹配，即：dp[i - 1] [j]，所以递推公式为：dp[i] [j] = dp[i - 1] [j]；这样当计算到dp[m+1] [n+1]即为结果。&lt;/p&gt;
&lt;p&gt;(4) Analyze the complexity of your algorithm&lt;/p&gt;
&lt;p&gt;时间复杂度：O(mn)，其中 m 和 n 分别是字符串 S 和 T 的长度。二维数组 dp 有 m+1 行和 n+1 列，需要对 dp 中的 mn 个元素进行计算。&lt;/p&gt;
&lt;h3 id=&#34;4-word-break&#34;&gt;4 Word Break&lt;/h3&gt;
&lt;p&gt;​		Given a string S and a dictionary of words, determine if the string S can be segmented into a space-separated sequence of one or more dictionary words.&lt;/p&gt;
&lt;p&gt;​		Note: Each word in the dictionary may be reused multiple times in the segmentation. You can return TRUE if the string S is empty.&lt;/p&gt;
&lt;p&gt;(1) Describe the optimal substructure and DP equation&lt;/p&gt;
&lt;p&gt;dp[i] 表示字符串S的下标为0~i-1的子串能否被字典中的单词组合表示。对于S[0&amp;hellip;i-1]可以分割为俩个部分S[0&amp;hellip;j-1]和 S[j&amp;hellip;i-1]，而 dp[j] 表示S[0&amp;hellip;j-1]的子串是否可以被字典中的单词组合而成，只需判断S[j&amp;hellip;i-1] 即可：&lt;/p&gt;
&lt;p&gt;​			dp[i] = dp[j] &amp;amp;&amp;amp; dict contains S[j&amp;hellip;i-1]&lt;/p&gt;
&lt;p&gt;(2) Describe your algorithm in pseudo-code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function wordBreak(S, dict)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: len = S.length
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2: define an array dp with size of len;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3: dp[0] = true;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4: for i = 1 to len do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5:     for j = 0 to i - 1 do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6:         if dp[j] &amp;amp;&amp;amp; dict contains S[j, i - j] then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7:             dp[i] = true;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8:             break;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;9:         end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10:    end for
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:end for
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;12:return dp[len];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(3) Prove the correctness of your algorithm&lt;/p&gt;
&lt;p&gt;dp[i] 表示字符串S的下标为0~i-1的子串能否被字典中的单词组合表示。计算 dp[i] 时，对于S[0&amp;hellip;i-1]可以分割为俩个部分S[0&amp;hellip;j-1]和 S[j&amp;hellip;i-1]，枚举每一个 j，如果左半部分S[0&amp;hellip;j-1] 和右半部分S[j&amp;hellip;i-1]都可以由字典中的单词组合而成则S[0&amp;hellip;i-1]部分就可以由字典中的单词组合而成。而 dp[j] 刚好表示S[0&amp;hellip;j-1]的子串是否可以被字典中的单词组合而成，而计算 dp[i] 时dp[j] 已经有了结果，只需要判断 S[j&amp;hellip;i-1] 部分是否在字典中即可，如果在字典中，说明这左右俩部分都可以由字典中的单词组合而成，也就说明dp[i] 所表示的 S[0&amp;hellip;i-1] 可以由字典中的单词组合而成，dp[i] = true。这样当计算到dp[n]即可得到结果。&lt;/p&gt;
&lt;p&gt;(4) Analyze the complexity of your algorithm&lt;/p&gt;
&lt;p&gt;假设判断某个字符串是否出现在字典中使用哈希表查找来实现，则时间复杂度为O(1)，这样，一共需要求dp数组中的n个值，求解每个值需要的时间复杂度为O(n)，则总的时间复杂度为O(n^2^)。&lt;/p&gt;
&lt;h3 id=&#34;3-unique-binary-search-trees&#34;&gt;3 Unique Binary Search Trees&lt;/h3&gt;
&lt;p&gt;​		Given n, how many structurally unique BST’s (binary search trees) that store values 1&amp;hellip;n?&lt;/p&gt;
&lt;p&gt;​		Explanation: Given n = 3, there are a total of 5 unique BST’s:&lt;/p&gt;
&lt;p&gt;(1) Describe the optimal substructure and DP equation&lt;/p&gt;
&lt;p&gt;对于序列 1&amp;hellip;n，分别以每个元素 i 作为根节点建立二叉搜索树，则根节点左侧的序列为 1 ~ i-1，根节点右侧的序列为 i+1 ~ n，然后按照同样的方法对根节点左右俩个子序列构建左右二叉搜索子树。以 dp[n] 表示对于序列 1&amp;hellip;n可以构建的不同的二叉搜索树为 dp[n] 个，以 f(i) 表示以 i （1 &amp;lt;= i &amp;lt;= n）为根节点，可以构建的不同的二叉搜索树的个数，则有：&lt;/p&gt;
&lt;p&gt;​		dp[n] = f(1) + f(2) + &amp;hellip; + f(n)，&lt;/p&gt;
&lt;p&gt;而对于每个 f(i) 有：&lt;/p&gt;
&lt;p&gt;​		f(i) = dp[i-1] * dp[n-i]，&lt;/p&gt;
&lt;p&gt;则 dp[n] = dp[0] * dp[n-1] + dp[1] * dp[n-2] + &amp;hellip; + dp[n-1] * dp[0]。&lt;/p&gt;
&lt;p&gt;(2) Describe your algorithm in pseudo-code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function numTrees(n)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: define an array dp[n+1] and assign a value of 0 to each element;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2: dp[0] = 1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3: dp[1] = 1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4: dp[2] = 2;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5: for i = 3 to n do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6:     for j = 1 to i do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7:         dp[i] += dp[j - 1] * dp[i - j];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8:     end for
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;9: end for
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10:return dp[n];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(3) Prove the correctness of your algorithm&lt;/p&gt;
&lt;p&gt;对于序列 1 &amp;hellip; n，分别以每个元素 i 作为根节点建立二叉搜索树，则左侧序列为 1 &amp;hellip; i-1，右侧的序列为 i+1 &amp;hellip; n，符合二叉搜索树的特性，然后对俩侧的序列采用同样的方法，由于每次选择的根节点不同，则建立的二叉搜索树也不同。&lt;/p&gt;
&lt;p&gt;首先，对于长度为 k 的俩个序列 1 &amp;hellip; k 和 k+1 &amp;hellip; 2k 它们分别能够构建的不同的二叉搜索树的个数是相同的，设为dp[k]，则可定义数组dp[n] 为长度为 n 的序列能够构建的不同的二叉搜索树个数为 dp[n]；以 f(i) 表示为以 i （1 &amp;lt;= i &amp;lt;= n）为根节点可以构建的二叉搜索树的个数，且 f(i) 之间相互独立，则有:&lt;/p&gt;
&lt;p&gt;​								dp[n] = f(1) + f(2) + &amp;hellip; + f(n)&lt;/p&gt;
&lt;p&gt;以 i 为根节点可以建立的二叉搜索树的个数为 其左侧序列可以建立的二叉搜索树的个数和其右侧节点可以建立的二叉搜索树的个数的乘积，即：&lt;/p&gt;
&lt;p&gt;​								f(i) = dp[i-1] * dp[n-i]&lt;/p&gt;
&lt;p&gt;设dp[0] = 1,则有 dp[n] 的解：&lt;/p&gt;
&lt;p&gt;​								 dp[n] = dp[0] * dp[n-1] + dp[1] * dp[n-2] + &amp;hellip; + dp[n-1] * dp[0]&lt;/p&gt;
&lt;p&gt;(4) Analyze the complexity of your algorithm&lt;/p&gt;
&lt;p&gt;需要求解dp数组的n个数，每个数的求解复杂度为O(n)，所以总的时间复杂度为O(n^2^)。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Greedy算法3道题</title>
        <link>http://ydsungan.com/p/greedy%E7%AE%97%E6%B3%953%E9%81%93%E9%A2%98/</link>
        <pubDate>Sat, 16 Apr 2022 15:06:12 +0800</pubDate>
        
        <guid>http://ydsungan.com/p/greedy%E7%AE%97%E6%B3%953%E9%81%93%E9%A2%98/</guid>
        <description>&lt;h3 id=&#34;3-cross-the-river&#34;&gt;3 Cross the River&lt;/h3&gt;
&lt;p&gt;Some people want to cross a river by boat. Each person has a weight, and each boat can carry an equal maximum weight limit. Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most boat’s weight limit. Return the minimum number of boats to carry every given person.&lt;/p&gt;
&lt;p&gt;Note that it is guaranteed each person can be carried by a boat.&lt;/p&gt;
&lt;p&gt;(1). Describe the basic idea of your algorithm in natural language&lt;/p&gt;
&lt;p&gt;首先将 people 数组升序排序，定义俩个指针，初始时，一个指向数组的头部，另一个指向数组的尾部，俩个指针所指向的人的体重之和如果小于或等于 limit，那么这俩个人可以坐一艘船离开，然后俩个指针相向各移动一位；否则，只能是体重大的乘船离开，指向尾部的指针向左移动一位。&lt;/p&gt;
&lt;p&gt;(2). Pseudo-code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function crossTheRiver(people, limit)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: sort people in ascending order;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2: i = 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3: j = people.num - 1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4: boats = 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5: while i &amp;lt;= j do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6:     if people[i] + people[j] &amp;lt;= limit then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7:         i += 1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8:         j -= 1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;9:         boats += 1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10:    else then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:        j -= 1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;12:        boats += 1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;13:    end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;14:end while
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;15:return boats;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(3). Describe the greedy-choice property and optimal substructure&lt;/p&gt;
&lt;p&gt;贪心选择思想：体重最小的人选择和体重最大的人乘同一艘船，这样能最大利用船的承重，如果这俩个人不满足要求，则体重最大的人单独乘船离开。&lt;/p&gt;
&lt;p&gt;从 people 中去除乘船离开的人，对于剩下的人而言，问题的结构没有发生改变，即问题的规模由 n 变成 n -1 或者 n - 2，使用同样的方法来分配乘船。&lt;/p&gt;
&lt;p&gt;所以最优子结构是：每次在当前剩余的人当中选择体重最小和体重最大的一起乘船，如果不能同时乘船，那么让体重最大的人单独乘船。&lt;/p&gt;
&lt;p&gt;(4). Prove the correctness of your algorithm&lt;/p&gt;
&lt;p&gt;首先对所有人的体重从小到大排序，这样对于体重最小的人，如果他能和体重最大的人乘同一艘船，那么他能和所有人乘同一艘船。所以贪心选择的思想是这个体重最小的人选择和体重最大的人乘同一艘船，可以最大利用船的承重。当俩人离开后，对剩下的人而言问题的结构没有发生变化，采用同样的方法来分配乘船。&lt;/p&gt;
&lt;p&gt;而对于体重最小的人，如果他不能和体重最大的人乘同一艘船，那么没有人能和体重最大的人乘同一艘船，所以体重最大的人应该单独乘船离开。当他离开后，对剩下的人而言问题的结构没有发生变化，采用同样的方法来分配乘船。&lt;/p&gt;
&lt;p&gt;(5). Analyse the complexity of your algorithm&lt;/p&gt;
&lt;p&gt;排序的时间复杂度为 O(nlogn)，而使用双指针计算的复杂度为 O(n)，所以总的时间复杂度为 O(nlogn)。&lt;/p&gt;
&lt;h3 id=&#34;6-maximum-number-of-coins-you-can-get&#34;&gt;6 Maximum Number of Coins You Can Get&lt;/h3&gt;
&lt;p&gt;There are 3n piles of coins of different size, you and your friends will take piles of coins as follows: In each step, you will choose any 3 piles of coins (not necessarily consecutive). Your friend Alice will pick the pile with the maximum number of coins. You will pick the pile with submaximal number of coins. Your friend Bob will pick the last pile. Repeat until there are no more piles of coins. Given an array of integers piles where piles[i] is the number of coins in the i-th pile. Return the maximum number of coins which you can have.&lt;/p&gt;
&lt;p&gt;(1). Describe the basic idea of your algorithm in natural language&lt;/p&gt;
&lt;p&gt;首先将 piles 按照升序排序，piles 的大小为 3n，则能够获得的最多的硬币的数量的组成的堆为第 n+1 堆，第 n + 3堆，&amp;hellip;，第 3n-1 堆的硬币数量和。&lt;/p&gt;
&lt;p&gt;(2).  Pseudo-code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function maxNumOfCoins(piles)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: sort piles in ascending order;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2: n = piles.length / 3;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3: max = 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4: for i = n to 3*n-2 , i += 2 do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5:     max += piles[i];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6: end for
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7: return max;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(3). Describe the greedy-choice property and optimal substructure&lt;/p&gt;
&lt;p&gt;贪心选择思想：3n堆硬币中，因为Alice每次必须选择最多的硬币，我必须获得第二多的硬币才能使自己的收益最大，为了使Bob不影响我的收益，Bob取最少的硬币；所以每次取的3堆中，第一堆和第二堆的硬币数量应该是当前所有堆中最多的和第二多的，第三堆的硬币数量该是当前堆中硬币最少的。&lt;/p&gt;
&lt;p&gt;取当前所有堆中第一多和第二多以及最少的3堆，除去这3堆后，对于剩下的 3n-3 堆，问题的结构不变，仍以同样方法取即可。&lt;/p&gt;
&lt;p&gt;所以最优子结构是：每次都是取当前所有堆中的第一多、第二多、最少的3堆，这3堆中，我取第二多的堆，所有堆的硬币总数就是我的最大收益。&lt;/p&gt;
&lt;p&gt;(4). Prove the correctness of your algorithm&lt;/p&gt;
&lt;p&gt;3n堆硬币中，硬币最多的一堆无论如何都会被Alice取走，当Alice每次取走第一多的，显然我必须取下剩余的最多的一堆，才使自己的收益最大。所以关键是Bob怎么取。&lt;/p&gt;
&lt;p&gt;如果Bob第一次取了 3n 堆中第3多的，第二次我只能取第5多的，而如果Bob第一次取的是很少的一堆硬币，第二次我能取第4多的，显然Bob的取法会影响我的最大收益，如果Bob每次都是取最少的一堆硬币，就把影响降至最低。&lt;/p&gt;
&lt;p&gt;(5). Analyse the complexity of your algorithm&lt;/p&gt;
&lt;p&gt;n 为 piles 数组的长度，则排序的时间复杂度为 O(nlogn)，而遍历数组的时间复杂度为 O(n)，所以总的时间复杂度为 O(nlogn)。&lt;/p&gt;
&lt;h3 id=&#34;4-permutation-partition&#34;&gt;4 Permutation Partition&lt;/h3&gt;
&lt;p&gt;Bob is given a permutation p~1~, p~2~, . . . , p~n~ of integers from 1 to n and an integer k, such that 1 ≤ k ≤ n. A permutation means that every number from 1 to n is contained exactly once.&lt;/p&gt;
&lt;p&gt;Consider all partitions of this permutation into k disjoint segments. Formally, a partition is a set of segments {[s~0~, s~1~], [s~1~ + 1, s~2~], . . . , [s~k−1~ + 1, s~k~]}, such that: 1 = s~0~ &amp;lt; s~1~ &amp;lt; s~2~ &amp;lt; . . . &amp;lt; s~k−1~ &amp;lt; s~k~ = n. Two partitions are different if there exists a segment that lies in one partition but not the other.&lt;/p&gt;
&lt;p&gt;Bob wants to calculate the partition value, defined as  i=1 max s~i−1~≤ j ≤ s~i~ p~j~ for all possible partitions of the permutation into k disjoint segments. Please help him find the maximum possible partition value over all such partitions, and the number of ways to make partition with this value.&lt;/p&gt;
&lt;p&gt;(1). Describe the basic idea of your algorithm in natural language&lt;/p&gt;
&lt;p&gt;定义变量 max 为最大分区值并初始化为0，定义变量 num 为达到这个最大分区值的方法数并初始化为1，定义变量 prev 记录上一个分组的最大值的位置并初始化为0，遍历排列中的每个元素，如果某个元素的值大于 n - k，则将 max 加上其值，且如果不是第一个元素，则将该元素的位置与 prev 的差值和 num 相乘，再将 prev 指向该元素的位置。&lt;/p&gt;
&lt;p&gt;(2).  Pseudo-code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;function partition(permutation, k, n)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1: max = 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2: num = 1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3: prev = 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4: for i = 0 to n - 1 do
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5:     if permutation[i] &amp;gt; n - k then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;6:         max += permutation[i];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;7:         if i &amp;gt; 0 then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8:             num = num * (i - prev)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;9:         end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;10:	       prev = i
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11:    end if
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;12:end for
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;13:return max, num
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;(3). Describe the greedy-choice property and optimal substructure&lt;/p&gt;
&lt;p&gt;贪心选择思想：选出排列中的最大的 k 个数，将这 k 个数分别划分在 k 个不同组中。&lt;/p&gt;
&lt;p&gt;(4). Prove the correctness of your algorithm&lt;/p&gt;
&lt;p&gt;对于将排列分k组，选出最大的分区值，显然最大的分区值为排列中最大的 k 个数的相加和，所以把这 k 个数分别划分在 k 个不同组即可。&lt;/p&gt;
&lt;p&gt;对如如何取得最大的 k 个值，本算法没有选择排序，只需要在遍历排列元素的时候判断该元素值是否大于 n - k 即可，因为这个排列是由 1 ~ n 组成的无重复元素的 n 大小的排列，只要元素值大于 n - k 即可判断属于最大的 k 个值之列。&lt;/p&gt;
&lt;p&gt;在确定了 k 个最大值之后，每两个最大值之间的划分方法为这俩个最大值之间的元素的个数加1，所以在所有最大值之间划分的方法就是这些值逐个相乘即可。&lt;/p&gt;
&lt;p&gt;(5). Analyse the complexity of your algorithm&lt;/p&gt;
&lt;p&gt;该算法需要遍历整个排列，所以时间复杂度为 O(n)，n 为排列的长度。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>intel CPU 不同平台介绍</title>
        <link>http://ydsungan.com/p/intel-cpu-%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E4%BB%8B%E7%BB%8D/</link>
        <pubDate>Mon, 04 Apr 2022 10:33:12 +0800</pubDate>
        
        <guid>http://ydsungan.com/p/intel-cpu-%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E4%BB%8B%E7%BB%8D/</guid>
        <description>&lt;img src="http://ydsungan.com/post/intel_xe.jpg" alt="Featured image of post intel CPU 不同平台介绍" /&gt;&lt;h1 id=&#34;系列一览&#34;&gt;系列一览&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;酷睿&lt;/strong&gt;-core&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;i9 处理器【第8代】-【第12代】&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;i7 处理器【第4代】-【第12代】&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;i5 处理器【第4代】-【第12代】&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;i3 处理器【第4代】-【第12代】&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;m 处理器【第5代】-【第8代】&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;传统酷睿处理器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-xeon&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;可扩展处理器【第1代】-【第3代】（金牌-银牌-铜牌-铂金）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;至强 E 处理器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;至强 W 处理器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;至强 D 处理器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;E7 处理器【v1】-【v4】&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;E5 处理器【v1】-【v4】&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;E3 处理器【v1】-【v6】&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;奔腾-pentium&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;奔腾 D 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;奔腾 G 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;奔腾 J 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;奔腾 N 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;奔腾金牌系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;奔腾银牌系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;奔腾 1000 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;奔腾 2000 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;奔腾 3000 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;奔腾 4000 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;奔腾 6800 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;奔腾 8000 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;赛扬-celeron&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;赛扬 G 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;赛扬 J 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;赛扬 N 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;赛扬 1000 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;赛扬 2000 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;赛扬 3000 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;赛扬 4000 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;赛扬 5000 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;赛扬 6000 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;赛扬 7000 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;凌动-atom&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;凌动 C 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;凌动 D 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;凌动 E 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;凌动 N 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;凌动 P 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;凌动 S 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;凌动 X 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;凌动 Z 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;安腾-Itanium&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;安腾 9000 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;安腾 9100 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;安腾 9300 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;安腾 9500 系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强融核-xeon-phi&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;至强融合 x100 家族&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;至强融合 x200 家族&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;第三代至强可扩展处理器&#34;&gt;&lt;strong&gt;第三代至强可扩展处理器&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;编号的解释：&lt;em&gt;系列-家族-编号-架构代号-发行-光刻-售价美金&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规格的解释：&lt;em&gt;内核数-线程数-基础频率-L3缓存-功耗&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持的解释：&lt;em&gt;内存通道数-是否支持超线程-是否支持傲腾DCPMM-是否支持TSX&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;超线程&lt;/strong&gt;：一个物理内核支持2个线程，比如常见的“4核8线程”&lt;/p&gt;
&lt;p&gt;Linux中可以通过下面指令查看内核数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cat /proc/cpuinfo &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep &lt;span class=&#34;s2&#34;&gt;&amp;#34;cpu cores&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; uniq
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Linux中可以通过下面指令查看总的线程数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cat /proc/cpuinfo &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep &lt;span class=&#34;s2&#34;&gt;&amp;#34;processor&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; wc -l
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;内存通道&lt;/strong&gt;：CPU里面有几个内存通道就是几个内存控制器，即iMC，这些内存控制器可以相互独立工作，从而使得内存的带宽增加一倍。现在的一般家用的CPU都是双通道，也就是说插2个8G的内存条远比插一个16GB的内存条性能高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存&lt;/strong&gt;：CPU每个核都是独占一个L1、L2缓存，唯独L3缓存是每个核共享的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;编号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;规格&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-金牌-5315Y-IceLake-21Q2-10-958&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8-16-3.2-12-140&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8-是-是-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-金牌-5320-IceLake-21Q2-10-1670&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;26-52-2.2-39-185&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8-是-是-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-金牌-6330-IceLake-21Q2-10-2030&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;28-56-2.0-42-205&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8-是-是-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-金牌-6348-IceLake-21Q2-10-3287&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;28-56-2.6-42-235&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8-是-是-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-铂金-8358-IceLake-21Q2-10-4227&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;32-64-2.6-48-250&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8-是-是-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-铂金-8360Y-IceLake-21Q2-10-5031&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;36-72-2.4-54-250&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8-是-是-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-铂金-8368Q-IceLake-21Q2-10-7214&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;38-76-2.6-57-270&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8-是-是-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-银牌-4316-IceLake-21Q2-10-1080&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;20-40-2.3-30-150&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8-是-是-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-金牌-5318H-CooperLake-20Q2-14-1273&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;18-36-2.5-24.75-150&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-是-是-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-铂金-8376H-CooperLake-20Q2-14-8719&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;28-56-2.6-38.5-205&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-是-是-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-金牌-6330H-CooperLake-20Q3-14-1894&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;24-48-2.0-33-150&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-是-是-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;第二代至强可扩展处理器&#34;&gt;&lt;strong&gt;第二代至强可扩展处理器&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;编号的解释：&lt;em&gt;系列-家族-编号-架构代号-发行-光刻-售价美元&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规格的解释：&lt;em&gt;内核数-线程数-基础频率-L3缓存-功耗&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持的解释：&lt;em&gt;内存通道数-是否支持超线程-是否支持傲腾DCPMM-是否支持TSX&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;编号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;规格&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-金牌-3206R-CascadeLake-20Q1-14-330&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8-8-1.9-11-85&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-否-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-金牌-5220R-CascadeLake-20Q1-14-1670&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;24-48-2.2-35.75-150&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-是-是-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-金牌-6230-Cascade Lake-19Q2-14-2030&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;20-40-2.1-27.5-125&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-是-是-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-金牌-6256-CascadeLake-20Q1-14-4174&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;12-24-3.6-33-205&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-是-是-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-银牌-4214R-CascadeLake-20Q1-14-750&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;12-24-2.4-16.5-100&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-铂金-8270-CascadeLake-19Q2-14-7922&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;26-52-2.7-35.75-205&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-是-是-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-铂金-8280-CascadeLake-19Q2-14-10710&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;28-56-2.7-38.5-205&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-是-是-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-铂金-9242-CascadeLake-19Q2-14-?&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;48-96-2.3-71.5-350&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;12-是-?-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;第一代至强可扩展处理器&#34;&gt;&lt;strong&gt;第一代至强可扩展处理器&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;编号的解释：&lt;em&gt;系列-家族-编号-架构代号-发行-光刻-售价美元&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规格的解释：&lt;em&gt;内核数-线程数-基础频率-L3缓存-功耗&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持的解释：&lt;em&gt;内存通道数-是否支持超线程-是否支持傲腾DCPMM-是否支持TSX&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;编号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;规格&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-金牌-6138P-Skylake-18Q2-14-4937&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;20-40-2.0-27.5-195&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-铜牌-3104-Skylake-17Q3-14&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-6-1.7-8.25-85&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-否-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-金牌-6150-Skylake-17Q3-14-3358&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;18-36-2.7-24.75-165&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-铂金-8160T-Skylake-17Q3-14-4936&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;24-48-2.1-33-150&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-银牌-4110-Skylake-17Q3-14-505&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8-16-2.1-11-85&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;至强-银牌-4108-Skylake-17Q3-14-420&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8-16-1.8-11-85&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;至强-e7-v4家族&#34;&gt;&lt;strong&gt;至强-E7-V4家族&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;编号的解释：&lt;em&gt;编号-架构代号-发行-光刻-售价美元&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规格的解释：&lt;em&gt;内核数-线程数-基础频率-L3缓存-功耗&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持的解释：&lt;em&gt;内存通道数-是否支持超线程-是否支持傲腾DCPMM-是否支持TSX&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;编号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;规格&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E7-8894V4-Broadwell-17Q1-14-8898&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;24-28-2.4-60-165&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E7-4809V4-Broadwell-16Q2-14-1223&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8-16-2.1-20-115&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E7-8891V4-Broadwell-16Q2-14-6841&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;10-20-2.8-60-165&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;至强-e7-v3家族&#34;&gt;&lt;strong&gt;至强-E7-V3家族&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;编号的解释：&lt;em&gt;编号-架构代号-发行-光刻-售价美元&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规格的解释：&lt;em&gt;内核数-线程数-基础频率-L3缓存-功耗&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持的解释：&lt;em&gt;内存通道数-是否支持超线程-是否支持傲腾DCPMM-是否支持TSX&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;编号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;规格&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E7-4809V3-Haswell-15Q2-22-1223&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8-16-2.0-20-115&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E7-8890V3-Haswell-15Q2-22-7174&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;18-36-2.5-45-165&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E7-8867V3-Haswell-15Q2-22-4672&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;16-32-2.5-45-165&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;至强-e7-v2家族&#34;&gt;&lt;strong&gt;至强-E7-V2家族&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;编号的解释：&lt;em&gt;编号-架构代号-发行-光刻-售价美元&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规格的解释：&lt;em&gt;内核数-线程数-基础频率-L3缓存-功耗&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持的解释：&lt;em&gt;内存通道数-是否支持超线程-是否支持傲腾DCPMM-是否支持TSX&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;编号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;规格&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E7-2850V2-Ivy Bridge-14Q1-22-?&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;12-24-2.3-24-105&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-是-否-否&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E7-4830V2-Ivy Bridge-14Q1-22-2059&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;10-20-2.2-20-105&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-是-否-否&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E7-4890V2-Ivy Bridge-14Q1-22-6619&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;15-30-2.8-37.5-155&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-是-否-否&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;至强-e5-v4家族&#34;&gt;&lt;strong&gt;至强-E5-V4家族&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;编号的解释：&lt;em&gt;编号-架构代号-发行-光刻-售价美元&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规格的解释：&lt;em&gt;内核数-线程数-基础频率-L3缓存-功耗&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持的解释：&lt;em&gt;内存通道数-是否支持超线程-是否支持傲腾DCPMM-是否支持TSX&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;编号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;规格&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E5-2683V4-Broadwell-16Q1-14-1846&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;16-32-2.1-40-120&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E5-2699AV4-Broadwell-16Q2-14-4938&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;22-44-2.4-55-145&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E5-4610V4-Broadwell-16Q2-14-1219&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;10-20-1.8-25-105&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E5-1650V4-Broadwell-16Q2-14-621&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-12-3.6-15-140&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;至强-e5-v1家族&#34;&gt;&lt;strong&gt;至强-E5-V1家族&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;编号的解释：&lt;em&gt;编号-架构代号-发行-光刻-售价美元&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规格的解释：&lt;em&gt;内核数-线程数-基础频率-L3缓存-功耗&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持的解释：&lt;em&gt;内存通道数-是否支持超线程-是否支持傲腾DCPMM-是否支持TSX&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;编号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;规格&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E5-1428L-Sandy Bridge EN-12Q2-32-480&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-12-1.8-15-60&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-是-否-否&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E5-4610-Sandy Bridge EN-12Q2-32-1220&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-12-2.4-15-95&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-是-否-否&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E5-1660-Sandy Bridge EN-12Q2-32-1080&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-12-3.3-15-130&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-是-否-否&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;至强-e3-v6家族&#34;&gt;&lt;strong&gt;至强-E3-V6家族&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;编号的解释：&lt;em&gt;编号-架构代号-发行-光刻-售价美元&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规格的解释：&lt;em&gt;内核数-线程数-基础频率-L3缓存-功耗&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持的解释：&lt;em&gt;内存通道数-是否支持超线程-是否支持傲腾DCPMM-是否支持TSX&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;编号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;规格&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E3-1285V6-Kaby Lake-17Q3-14-450&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-8-4.1-8-79&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;2-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E3-1245V6-Kaby Lake-17Q1-14-290&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-8-3.7-8-73&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;2-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;E3-1505MV6-Kaby Lake-17Q1-14-434&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-8-3.0-8-45&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;2-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;至强-w-处理器&#34;&gt;&lt;strong&gt;至强 W 处理器&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;编号的解释：&lt;em&gt;编号-架构代号-发行-光刻-售价美元&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规格的解释：&lt;em&gt;内核数-线程数-基础频率-L3缓存-功耗&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持的解释：&lt;em&gt;内存通道数-是否支持超线程-是否支持傲腾DCPMM-是否支持TSX&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;编号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;规格&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;W-11155MLE-Tiger Lake-21Q3-10-242&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-8-1.8-8-25&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;2-是-否-否&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;W-11865MLE-Tiger Lake-21Q3-10-467&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8-16-1.5-24-25&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;2-是-否-否&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;W-3365-Ice Lake-21Q3-10-3499&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;32-64-2.7-48-270&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;8-是-否-是&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;至强-d-处理器&#34;&gt;&lt;strong&gt;至强 D 处理器&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;编号的解释：&lt;em&gt;编号-架构代号-发行-光刻-售价美元&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规格的解释：&lt;em&gt;内核数-线程数-基础频率-L3缓存-功耗&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持的解释：&lt;em&gt;最大内存大小-是否支持超线程-是否支持傲腾DCPMM-是否支持TSX&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;编号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;规格&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;D-1712TR-Ice Lake-22Q1-10-240&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-8-2.0-10-40&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;384-是-否-否&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;D-1718T-Ice Lake-22Q1-10-274&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-8-2.6-10-46&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;256-是-否-否&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;D-1747NTE-Ice Lake-22Q1-10-1201&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;10-20-2.5-15-80&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;384-是-否-否&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;酷睿-i7-第12代-处理器&#34;&gt;&lt;strong&gt;酷睿 i7 第12代 处理器&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;编号的解释：&lt;em&gt;编号-市场-架构代号-发行-光刻-售价美元&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规格的解释：&lt;em&gt;内核数-线程数-最大睿频-L3缓存-基础功耗&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持的解释：&lt;em&gt;最大内存-内存通道-是否支持TSX-最大DP-最大HDMI-核显&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;市场的Mobile表示适用于笔记本，Desktop表示适用于台式机。&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;编号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;规格&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i7-12700-Desktop-Alder Lake-22Q1-7-340&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;12-20-4.9-25-65&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;128-2-否-8K60帧-4K60帧-770&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i7-12650H-Mobile-Alder Lake-22Q1-7-457&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;10-16-4.7-24-45&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;64-2-否-8K60帧-4K60帧-?&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i7-12800H-Mobile-Alder Lake-22Q1-7-457&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;14-20-4.8-24-45&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;64-2-否-8K60帧-4K60帧-锐炬Xe&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;酷睿-i5-第12代-处理器&#34;&gt;&lt;strong&gt;酷睿 i5 第12代 处理器&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;编号的解释：&lt;em&gt;编号-市场-架构代号-发行-光刻-售价美元&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规格的解释：&lt;em&gt;内核数-线程数-最大睿频-L3缓存-基础功耗&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持的解释：&lt;em&gt;最大内存-内存通道-是否支持TSX-最大DP-最大HDMI-核显&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;市场的Mobile表示适用于笔记本，Desktop表示适用于台式机。&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;编号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;规格&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i5-1230U-Mobile-Alder Lake-22Q1-7-?&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;10-12-4.4-12-9&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;64-2-否-8K60帧-4K60帧-锐炬Xe&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i5-1245U-Mobile-Alder Lake-22Q1-7-309&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;10-12-4.4-12-15&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;64-2-否-8K60帧-4K60帧-锐炬Xe&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i5-12400-Desktop-Alder Lake-22Q1-7-199&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-12-4.4-18-65&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;128-2-否-8K60帧-4K60帧-730&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i5-12600-Desktop-Alder Lake-22Q1-7-230&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-12-4.8-18-65&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;128-2-否-8K60帧-4K60帧-770&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i5-12600H-Mobile-Alder Lake-22Q1-7-311&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;12-16-4.5-18-45&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;64-2-否-8K60帧-4K60帧-锐炬Xe&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;酷睿-i5-第11代-处理器&#34;&gt;&lt;strong&gt;酷睿 i5 第11代 处理器&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;编号的解释：&lt;em&gt;编号-市场-架构代号-发行-光刻-售价美元&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规格的解释：&lt;em&gt;内核数-线程数-最大睿频-L3缓存-基础功耗&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持的解释：&lt;em&gt;最大内存-内存通道-是否支持TSX-最大DP-最大HDMI-核显&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;市场的Mobile表示适用于笔记本，Desktop表示适用于台式机。&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;编号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;规格&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i5-11300H-Mobile-Tiger Lake-21Q1-10-309&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-8-4.4-8-28&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;64-2-否-8K60帧-4K60帧-锐炬Xe&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i5-1135G7-Mobile-Tiger Lake-20Q3-10-309&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-8-4.2-8-12&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;64-2-否-8K60帧-4K60帧-锐炬Xe&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i5-1145G7-Mobile-Tiger Lake-21Q1-10-309&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-8-4.4-8-12&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;64-2-否-8K60帧-4K60帧-锐炬Xe&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i5-1155G7-Mobile-Tiger Lake-21Q2-10-309&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-8-4.5-8-12&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;64-2-否-8K60帧-4K60帧-锐炬Xe&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i5-11400-Desktop-Rocket Lake-21Q1-14-182&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-12-4.4-12-65&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;128-2-否-5K60帧-4K60帧-730&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i5-1145G7-Mobile-Tiger Lake-21Q2-10-309&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-8-4.4-8-12&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;64-2-否-8K60帧-4K60帧-锐炬Xe&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i5-11600K-Desktop-Rocket Lake-21Q1-14-270&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-12-4.9-12-125&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;128-2-否-5K60帧-4K60帧-750&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;酷睿-i5-第10代-处理器&#34;&gt;&lt;strong&gt;酷睿 i5 第10代 处理器&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;编号的解释：&lt;em&gt;编号-市场-架构代号-发行-光刻-售价美元&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规格的解释：&lt;em&gt;内核数-线程数-最大睿频-L3缓存-基础功耗&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持的解释：&lt;em&gt;最大内存-内存通道-是否支持TSX-最大DP-最大HDMI-核显&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;市场的Mobile表示适用于笔记本，Desktop表示适用于台式机。&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;编号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;规格&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i5-10500H-Mobile-Comet Lake-20Q4-14-250&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-12-4.5-12-45&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;128-2-否-4K60帧-4K30帧-?&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i5-10210U-Mobile-Comet Lake-19Q3-14-297&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-8-4.2-6-15&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;64-2-否-4K60帧-4K30帧-?&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i5-10310U-Mobile-Comet Lake-20Q2-14-297&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;4-8-4.4-6-15&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;64-2-否-4K60帧-4K24帧-?&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;i5-10400F-Desktop-Comet Lake-20Q2-14-157&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6-12-4.3-12-65&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;128-2-否-无核显-无核显-无核显&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;奔腾金牌处理器&#34;&gt;&lt;strong&gt;奔腾金牌处理器&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;编号的解释：&lt;em&gt;编号-市场-架构代号-发行-光刻-售价美元&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规格的解释：&lt;em&gt;内核数-线程数-最大睿频-L3缓存-基础功耗&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持的解释：&lt;em&gt;最大内存-内存通道-是否支持TSX-最大DP-最大HDMI-核显&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;市场的Mobile表示适用于笔记本，Desktop表示适用于台式机。&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;编号&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;规格&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;G7400-Desktop-Alder Lake-22Q1-7-70&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;2-4-3.7-6-46&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;128-2-否-8K60帧-4K60帧-710&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;G6405-Desktop-Comet Lake-21Q1-14-64&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;2-4-4.1-4-58&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;128-2-否-4K60帧-4K30帧-610&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;6500Y-Mobile-Amber Lake Y-21Q1-14-?&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;2-4-1.1-4-5&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;16-2-否-3K60帧-4K24帧-615&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;4425Y-Mobile-Amber Lake-19Q1-14-161&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;2-4-1.7-2-6&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;16-2-否-4K60帧-4K24帧-615&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
        </item>
        <item>
        <title>NVM方向调研</title>
        <link>http://ydsungan.com/p/nvm%E6%96%B9%E5%90%91%E8%B0%83%E7%A0%94/</link>
        <pubDate>Thu, 31 Mar 2022 18:25:12 +0800</pubDate>
        
        <guid>http://ydsungan.com/p/nvm%E6%96%B9%E5%90%91%E8%B0%83%E7%A0%94/</guid>
        <description>&lt;img src="http://ydsungan.com/post/dcpmm.jpg" alt="Featured image of post NVM方向调研" /&gt;&lt;h1 id=&#34;研究方向&#34;&gt;研究方向&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;文件系统&lt;/li&gt;
&lt;li&gt;键值存储系统&lt;/li&gt;
&lt;li&gt;索引结构&lt;/li&gt;
&lt;li&gt;数据一致性&lt;/li&gt;
&lt;li&gt;磨损均衡&lt;/li&gt;
&lt;li&gt;动态图&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;傲腾pmem特性&#34;&gt;傲腾PMem特性&lt;/h1&gt;
&lt;h2 id=&#34;pmem架构&#34;&gt;PMem架构&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;每个 CPU 芯片有2个 iMC，每个 iMC 支持3个通道，所以每个 CPU 芯片支持6个傲腾DIMM。一台双 CPU 的服务器最大可装载 6TB (2 socket * 6 channel * 512GB/DIMM = 6TB)。&lt;/li&gt;
&lt;li&gt;使用 ADR 域来掉电保护；CPU中的 iMC 中为每个傲腾 DIMM 维护着读/写挂起队列，WPQ 在ADR 域中，只要数据达到 WPQ 中，ADR域即可确保在掉电后 iMC 把数据刷回 DIMM；Cache中的数据无法保护，ADR域中的 WPQ 和 XPBuffer 中的数据可以被持久化。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;pmem运行模式&#34;&gt;PMem运行模式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;内存模式&lt;/strong&gt;：DCPMM为易失性，一个DCPMM和一个DRAM组合在同一个内存通道上，DRAM 相当于一个 L4 级缓存，缓存块为 64B， DCPMM被视为主存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;直连模式&lt;/strong&gt;： DCPMM提供持久性，可以使用交错和非交错配置；交错的DCPMM被视为一个整体空间，将数据等量分散存储到各个DIMM，交错大小为4KB，类似RAID 0；非交错的DCPMM将一个 DIMM的内存空间追加到另一个DIMM的后面。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;pmem读写&#34;&gt;PMem读写&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;iMC 与傲腾 PMem 之间通过基于事物的双倍速率协议 (DDR-T) 以缓存行大小 (64B) 的粒度进行传输。&lt;/li&gt;
&lt;li&gt;傲腾 PMem 内部的最小读写粒度为 256B，内部用一个小的写合并缓冲区 XPBuffer 来解决 DDR-T协议传输粒度和傲腾 PMem 的操作粒度不一致的问题。例如，64 B的数据写操作需要先从傲腾 PMem中将对应的256 B数据读入到 XPBuffer 中，然后在 XPBuffer 中更新请求的64 B数据，最后再将256 B数据写入到傲腾PMem存储介质中。这一操作会导致写放大，降低傲腾PMM的性能。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;延时测试&#34;&gt;延时测试&lt;/h2&gt;
&lt;p&gt;傲腾 PMem 内部的最小读写粒度为 256B，内部用一个小的写合并缓冲区 XPBuffer 来解决 DDR-T协议传输粒度和傲腾 PMem 的操作粒度不一致的问题。例如，64 B的数据写操作需要先从傲腾 PMem中将对应的256 B数据读入到 XPBuffer 中，然后在 XPBuffer 中更新请求的64 B数据，最后再将256 B数据写入到傲腾PMem存储介质中。这一操作会导致写放大，降低傲腾PMM的性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ydsungan.com/post/timetest1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;延时测试&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;访问粒度对带宽的影响&#34;&gt;访问粒度对带宽的影响&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;DRAM：访问粒度的大小对读写带宽没什么影响；&lt;/li&gt;
&lt;li&gt;交错和非交错：访问粒度小于 256B时会造成较差的带宽，原因是 XPLine大小为 256B；&lt;/li&gt;
&lt;li&gt;非交错：读写带宽较非交错提升 5.8x 和 5.6x (与交错的DIMM个数接近)，在 4KB 处带宽降低，接近交错大小，最大化 iMC 竞争；尽量避免以4KB的交错大小进行随机访问；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://ydsungan.com/post/bandwidth1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;带宽测试&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;文件系统&#34;&gt;文件系统&lt;/h1&gt;
&lt;h2 id=&#34;传统块设备文件系统-vs-持久内存文件系统&#34;&gt;传统块设备文件系统 vs 持久内存文件系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基于块设备的文件系统：读写粒度通常为 512B 或 4KB，如文件系统需要修改块设备中的 8B 时，需要找到这 8B 所在的块号，将其所在的 4KB 块读取到内存中的 page cache中，再拷贝到应用缓冲区，在应用缓冲区中修改这 8B ，并将修改后的缓存页写回到块设备，是一个“读取-修改-写回”的过程，存在双份拷贝花销的问题、写放大问题、块设备访问速度慢导致大量的访问操作会带来 I/O 阻塞问题。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;读缓存&lt;/strong&gt;：文件访问具有时间局部性，从块设备读取了一个文件的数据后，可以让它在内存中保存一段时间，命中时可直接访问；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写缓冲区和写合并&lt;/strong&gt;：文件访问具有空间局部性，文件在高速缓存页中修改之后，不马上持久化，若后续再次请求修改相同的块时，可直接修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于持久内存的文件系统：NVM 设备直接连接在 DDR 内存通道，移除了页高速缓存和块设备的写入缓冲区和写入合并；具有可按字节寻址的特性，数据直接在文件系统和应用缓冲区之间通过 Load/Store 访存，无需以整个块粒度读写；&lt;/li&gt;
&lt;li&gt;持久内存文件系统的优点
&lt;ul&gt;
&lt;li&gt;访问文件数据不需要经过传统面向块设备的 I/O 软件层次，文件请求到内存级就直接返回;&lt;/li&gt;
&lt;li&gt;访问文件数据不需要多次拷贝，不需要经过 VFS 中的高速缓存，因为PM是直接装在内存总线上，直接在内存与用户进程缓冲区之间直接拷贝数据；&lt;/li&gt;
&lt;li&gt;访问NVM通常不会引起进程阻塞挂起。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://ydsungan.com/post/pm1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;持久内存文件系统架构&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;文件系统的结构特征&#34;&gt;文件系统的结构特征&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;索引结构：树形索引 vs 哈希索引 vs 跳表&lt;/li&gt;
&lt;li&gt;内存架构：纯NVM vs DRAM-NVM混合内存&lt;/li&gt;
&lt;li&gt;数据更新机制：日志型更新 vs 写时复制&lt;/li&gt;
&lt;li&gt;是否支持 MMap：是 vs 否&lt;/li&gt;
&lt;li&gt;访问均衡性：弱 vs 强&lt;/li&gt;
&lt;li&gt;一致性层级：元数据一致性 vs 数据一致性 vs 版本一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://ydsungan.com/post/fs.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;现有的研究工作&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据更新机制&#34;&gt;数据更新机制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;日志&lt;/strong&gt;：一种原地更新的方式，是指新数据在旧数据所在的位置上进行更新，新写入的数据将覆盖原有数据，对于可能存在的不完整写问题，一般采取记录日志 (Journaling) 的方式对被修改前的数据和被修改后的数据进行记录，更新完全成功后再丢弃日志。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写时复制&lt;/strong&gt;：一种异地更新方式，写时复制是指当进行数据更新时，先将原有数据原原本本地复制一份，然后在复制出的副本上进行数据修改，数据修改完成后再将数据原本删除，若修改失败，则将数据恢复到原本状态，这样就即可以完成数据更新，又保证了数据更新的一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;nvm-dram-混合内存文件系统&#34;&gt;NVM-DRAM 混合内存文件系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;DRAM 和 NVM 采用平行架构，DRAM 和 NVM 同时作为系统主存连接在内存控制器上，俩者采用统一编址的方式；&lt;/li&gt;
&lt;li&gt;关键的变化是如何确定 DRAM 和 NVM 各自存放程序的哪些数据，当系统发生异常时DRAM掉电易失，而 NVM 中的数据在 DRAM 中的数据已然丢失的情况下，如何维护数据一致性；&lt;/li&gt;
&lt;li&gt;对应为 Intel 傲腾持久内存的 App-Direct Mode，系统可用的总内存空间为DRAM和NVM容量之和。被更多的研究采用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://ydsungan.com/post/h1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;混合内存架构&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;键值存储系统&#34;&gt;键值存储系统&lt;/h1&gt;
&lt;h2 id=&#34;非关系型数据库&#34;&gt;非关系型数据库&lt;/h2&gt;
&lt;p&gt;主要可以分为四种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;键值对存储&lt;/strong&gt; (Key-Value Store)：其基本结构就是一个 Key-Value 的映射关系集合；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文档存储&lt;/strong&gt; (Document Store)：如MongoDB；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;列数据库&lt;/strong&gt; (Column-oriented Store)：将每一列分别单独存放数据。与基于行的传统关系型数据库的区别在于：以牺牲存储空间和更多的索引文件为代价使得查找速度得到提升，主要适用于批量数据处理和即时查询，而数据以行相关的存储体系架构，主要适合于大规模的数据处理和联机事务型数据处理；如Cassandra、HBase；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图数据库&lt;/strong&gt; (Graph Database)：又分为静态图和动态图。适用于被存储的数据之间具有较为紧密的联系，图形数据库主要由两部分组成，节点和连接边，节点表示实体本身，连接边表示实体之间的关系。如静态图数据库Neo4J、动态图数据库Stinger。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;k-v-store&#34;&gt;K-V store&lt;/h2&gt;
&lt;p&gt;键值对存储系统主要采用的数据结构：LSM树、B+树、哈希表、跳表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;LSM树&lt;/strong&gt;：LSM 树多用于 HDD 或 SSD 的键值对存储系统，在内存中将随机写请求聚集并顺序写到外存中，适应HDD 或 SSD的顺序写性能远远高于随机写性能的特性；LSM 树主要应用于查询频率远远低于写入频率的情况，能降低索引的写入开销。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希表&lt;/strong&gt;：主要被用在基于内存的场景中，利用了哈希表常数级别的点操作时间复杂度，包括Add、Get、Update、Delete等操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;索引结构&#34;&gt;索引结构&lt;/h1&gt;
&lt;h2 id=&#34;树型索引&#34;&gt;树型索引&lt;/h2&gt;
&lt;p&gt;一般B+树、基数树，为有序索引数据结构，范围查询的性能最好，但需要额外的开销来维护有序性。Add、Get、Update、Delete、Scan等操作的时间复杂度都为O(logN)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ydsungan.com/post/tree.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;现有研究工作&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;哈希索引结构&#34;&gt;哈希索引结构&lt;/h2&gt;
&lt;p&gt;哈希表完全不维护数据结构中的有序性，一般而言额外开销最小，范围查询时需要遍历所有的键值对，效率很低。不过Add、Get、Update、Delete等点操作类型的时间复杂度都是O(1)，性能优于树形索引结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态哈希&lt;/strong&gt;：适合数据集大小相对稳定的场景，在插入频繁的场景下，数据的波动较大，静态哈希要重建哈希索引进行扩容，导致大量的NVM写操作，造成性能的抖动和下降，且在并发时要对扩容的哈希索引加锁，导致索引的访问被阻塞。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态哈希&lt;/strong&gt;：包括可扩展哈希、线性哈希；动态哈希通过桶分裂来增量式扩容，扩容过程不需要重建整个哈希索引，而且不需要加锁，平衡了可扩展性和性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;布谷鸟散列&#34;&gt;布谷鸟散列&lt;/h3&gt;
&lt;p&gt;布谷鸟散列：使用俩个哈希函数分别计算 key对应的位置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若两个位置均为空，任选一个插入；&lt;/li&gt;
&lt;li&gt;若两个位置中一个为空，插入到空的位置；&lt;/li&gt;
&lt;li&gt;若两个位置均非空，则随机踢出一个位置上的 keyx，被踢出的 keyx 再执行该算法找其另一个位置，循环直到插入成功；&lt;/li&gt;
&lt;li&gt;如果被踢出的次数达到一定的阈值，则认为hash表已满，并进行重新哈希 rehashing。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;http://ydsungan.com/post/hash.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;现有工作研究&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;数据一致性&#34;&gt;数据一致性&lt;/h1&gt;
&lt;h2 id=&#34;数据的崩溃一致性问题&#34;&gt;数据的崩溃一致性问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写粒度问题&lt;/strong&gt;：CPU对SSD原子写的粒度为闪存页大小4KB ，对HDD原子写的粒度为扇区大小512B，可以保证一条日志的追加更新是原子性的。而CPU对NVM的原子写粒度只有8B，面临修改持久性数据的过程中发生断电导致数据不一致的问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存问题&lt;/strong&gt;：传统DRAM和Cache都是易失的，系统在DRAM和Cache之间采用写回法和写分配法的策略不会产生断电恢复的问题。而NVM作为全部内存时，CPU先写入Cache中，没有写入NVM中。这样指令运行结束之后，我们无法判断数据何时才会真正被持久化存储，在断电后无法判断数据出于何种状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPU重排序问题&lt;/strong&gt;：对于多周期流水线CPU，在一个基本时钟周期内同时从指令Cache中读出多条指令，同时对多条指令进行译码。当指令没有数据相关性时且有空闲运算部件时就会被执行，不能保证各个语句执行的先后顺序和输入代码中的顺序一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;原子更新技术sfenceclflush&#34;&gt;原子更新技术：sfence、clflush&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;内存屏障&lt;/strong&gt;：CPU 采用乱序调度来增加性能，但 NVM 的写入要保证顺序性否则会导致崩溃一致性的问题，内存屏障的方式如 sfence 指令，可以保证 cache line 刷回NVM 的顺序。但加入 sfence 等内存屏障指令降低 CPU 流水线效率会降低处理器性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存行刷新&lt;/strong&gt;：x86 提供了 clflush、clflushopt 和 clwb 等指令可以让数据在每次对NVM的写入操作之后从 cache line 强制写回到 NVM。但这些指令减少了Cache作为高速缓存的作用，降低了处理器性能。clwb 指令后跟着 sfence 指令为一次持久化操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ydsungan.com/post/flush1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;fl&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ydsungan.com/post/flush2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;fl&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;日志&#34;&gt;日志&lt;/h2&gt;
&lt;p&gt;redo日志、undo日志：或叫做写前日志，是一种原地更新设计。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;undo日志：原始值被修改之前，将原始值存储到undo日志中，如果修改出现异常，可以对undo日志进行回滚；&lt;/li&gt;
&lt;li&gt;redo日志：将数据位置和此位置上即将被写入的新数据保存在日志中，日志提交之后用户进行真正的修改，在恢复的时候根据这个日志把数据重写到记录的位置上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;redo 日志一旦提交，就认为已成功持久化，无论修改是否已经写到原位置上；
undo 日志使用时，数据修改的持久化取决于日志是否被标记为无效。只有真实的修改被写到原位置上，用户再将 undo 日志标记为无效，才能保证完成持久化。&lt;/p&gt;
&lt;h2 id=&#34;写时拷贝&#34;&gt;写时拷贝&lt;/h2&gt;
&lt;p&gt;写时拷贝：修改数据时，先对原数据进行一次拷贝，在拷贝出来的数据副本上进行修改。此后，写时拷贝通过继续修改指向原数据的指针，使其指向新数据，让副本中的数据修改生效。写时拷贝经常被用在树形结构中。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>内存管理</title>
        <link>http://ydsungan.com/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
        <pubDate>Wed, 30 Mar 2022 14:47:12 +0800</pubDate>
        
        <guid>http://ydsungan.com/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
        <description>&lt;h1 id=&#34;1-虚拟内存&#34;&gt;1 虚拟内存&lt;/h1&gt;
&lt;p&gt;​		内存是计算机系统的重要计算资源。在介绍具体的内存管理机制之前，先思考这个问题：当多个应用程序同时运行时，操作系统该如何让它们共同使用物理内存资源呢?&lt;/p&gt;
&lt;p&gt;​		一种简单的方法是：当一个应用程序 A 运行时，允许它访问所有的物理内存资源；在切换到另一个应用程序 B 运行的过程中，操作系统将应用程序 A 的所有内存数据保存到存储设备（如磁盘）中，然后将应用程序 B 的数据从存储设备加载到内存中。但是这种方法存在明显的弊端：由于读写存储设备的速度很慢，这将导致切换程序的时间开销太大。&lt;/p&gt;
&lt;p&gt;​		另—种简单的方法是：让每个应用程序独立使用物理内存的—部分，数据—直驻留在内存中，在程序切换时不再需要操作存储设备。该方法在性能方面优于前一种方法，但是也存在两个严重的弊端：第—，无法保证不同应用程序所使用的物理内存之间的隔离性，比如应用程序 A 在运行过程中可能意外地写了应用程序B的物理内存，进而导致后者错误运行；第二，无法保证应用程序可用的地址空间是连续的和统一的，增加了程序编写及编译的复杂性。&lt;/p&gt;
&lt;p&gt;​		操作系统究竟是如何让不同的应用程序能够既高效又安全地共同使用物理内存资源的？现代操作系统的一个普遍做法是在应用程序与物理内存之间加入一个新的抽象：&lt;strong&gt;虚拟内存&lt;/strong&gt;（virtual memory）。&lt;strong&gt;应用程序是面向虚拟内存编写的&lt;/strong&gt;，而不再是面向物理内存编写的；应用程序在运行时只能使用虚拟地址，CPU负责将虚拟地址翻译成物理地址，操作系统负责设置虚拟地址与物理地址之间的映射。操作系统仅将应用程序实际使用的虚拟地址映射到物理地址，从而提高内存资源的利用率；每个应用程序只能看到自己的虚拟地址空间。从而保证不同应用程序所用内存之间的隔离：每个应用程序的虚拟地址空间是统一的、连续的，从而降低了编程的复杂性。&lt;/p&gt;
&lt;h1 id=&#34;2-物理地址和虚拟地址&#34;&gt;2 物理地址和虚拟地址&lt;/h1&gt;
&lt;p&gt;​		逻辑上，可以把物理内存看成一个大数组，其中每个字节都可以通过与之唯—对应的地址进行访问，这个地址就是&lt;strong&gt;物理地址&lt;/strong&gt;（physical address）。在应用程序或操作系统运行过程中，CPU通过总线发送访问物理地址的请求，从内存中读取数据或者向其中写人数据。&lt;/p&gt;
&lt;p&gt;​		在引人虚拟内存的抽象后应用程序使用&lt;strong&gt;虚拟地址&lt;/strong&gt;（virtual address）访问存储在内存中的数据和代码。在程序扶行过程中，CPU会把虚拟地址转换成物理地址，然后通过后者访问物理内存。虚拟地址转换成物理地址的过程，通常被称为&lt;strong&gt;地址翻译&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;21-使用虚拟地址访问内存单元&#34;&gt;2.1 使用虚拟地址访问内存单元&lt;/h2&gt;
&lt;p&gt;​		CPU中的重要部件，&lt;strong&gt;内存管理单元&lt;/strong&gt;（Memory Management Unit，&lt;strong&gt;MMU&lt;/strong&gt;），负责虚拟地址到物理地址的转换。程序在CPU核心上运行期间，它使用的虚拟地址都会由 MMU 进行翻译。当需要访问物理内存设备的时候，MMU 翻译出的物理地址将会通过总线传到相应的物理内存设备，从而完成相应的物理内存读写请求。&lt;/p&gt;
&lt;p&gt;​		以运行Hello World 程序的第—条指令为例：操作系统首先把程序从磁盘／SSD 加载到物理内存中，然后让CPU去执行程序的第—条指令，但是此时该指令存在于内存中。在使用虚拟内存的情况下，CPU取指令时发出的是指令的虚拟地址，该虚拟地址被 MMU翻译为对应的物理地址，包含该物理地址的内存读请求被发送到物理内存设备，然后物理内存设备把该物理地址对应的内容（即Hello World程序的第一条指令）发送给 CPU。&lt;/p&gt;
&lt;p&gt;​		为了加速地址翻译的过程，现代CPU都引人了转址旁路缓存（Translation Lookaside Buffer，TLB）。TLB是属于MMU内部的单元。&lt;/p&gt;
&lt;h2 id=&#34;22-分段和分页机制&#34;&gt;2.2 分段和分页机制&lt;/h2&gt;
&lt;p&gt;​		MMU将虚拟地址翻译为物理地址的主要机制有两种：分段机制和分页机制。&lt;/p&gt;
&lt;p&gt;​		在分段机制下，不仅虚拟内存空间被划分成不同的段，物理内存也以段为单位进行分配。在虚拟地址空间中，相邻的段所对应的物理内存中的段可以不相邻，因此，操作系统能够实现物理内存资源的离散分配。分段容易导致外部碎片。例如：如果一共有 6GB 的物理内存，目前被划分成4 段进行分配，第—段为0～2GB，第二段为2～3GB，第三段为3～5GB，第四段为 5～6GB；如果第二段和第四段被释放，然后又需要分配—个2GB的段，虽然此时空闲的物理内存总量为2GB，但因为这2GB内存不连续，因此分配还是会失败。&lt;/p&gt;
&lt;p&gt;​		应用程序的虚拟地址空间由若干个&lt;strong&gt;不同大小的段&lt;/strong&gt;组成，比如代码段、数据段等。当 CPU访问虚拟地址空间中某一个段的时候，MMU 会通过查询&lt;strong&gt;段表&lt;/strong&gt;得到该段对应的物理内存区域。具体来说，虚拟地址由两部分构成：第—个部分表示段号，标识着该虚拟地址属于整个虚拟地址空间中的哪—个段；第二个部分表示段内地址，或称段内偏移，即相对于该段起始地址的偏移量。&lt;/p&gt;
&lt;p&gt;​		现代操作系统广泛采用的是分页机制。分页机制将应用程序的虚拟地址空间划分成&lt;strong&gt;连续的、等长的虚拟页&lt;/strong&gt;，不同于分段机制下大小不同的段。虚拟页和物理页的页长固定且相等。&lt;/p&gt;
&lt;p&gt;​		在分页机制下，应用程序虚拟地址空间中的任意虚拟页可以被映射到物理内存中的任意物理页上。因此操作系统也能实现物理内存资源的离散分配。分页机制按照固定页大小分配物理内存，使得物理内存资源易于管理可有效避免分段机制中外部碎片的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ydsungan.com/post/memory_1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;memory&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-虚拟内存的功能&#34;&gt;2.3 虚拟内存的功能&lt;/h2&gt;
&lt;p&gt;​		&lt;strong&gt;共享内存&lt;/strong&gt; (shared memory) 允许同—个物理页在不同的应用程序间共享，例如，应用程序 A 的虚拟页 V1 被映射到物理页P，若应用程序B的虚拟页 V2 也被映射到物理页P，则物理页 P 是应用程序 A 和应用程序 B 的共享内存。应用程序 A 读取虚拟页 V1 和应用程序 B 读取虚拟页 V2 将得到相同的内容，互相也能看到对方修改的内容。共享内存的一个基本用途是可以让不同的应用程序之间互相通信、传递数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ydsungan.com/post/memory_2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;memory2&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>页缓存、直接IO及内存映射</title>
        <link>http://ydsungan.com/p/%E9%A1%B5%E7%BC%93%E5%AD%98%E7%9B%B4%E6%8E%A5io%E5%8F%8A%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/</link>
        <pubDate>Wed, 30 Mar 2022 14:30:12 +0800</pubDate>
        
        <guid>http://ydsungan.com/p/%E9%A1%B5%E7%BC%93%E5%AD%98%E7%9B%B4%E6%8E%A5io%E5%8F%8A%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/</guid>
        <description>&lt;p&gt;​		对文件系统中结构的修改都是直接在存储设备中进行的。然而在存储设备上直接访问数据有两个问题。首先，目前大多数存储设备都是块接口，读写粒度为—个块，大小通常为 512B 或者 4KB。然而文件系统所进行的更改往往并非对齐到块的边界，其读写的字节数也并非恰好为块大小的整数倍。其次，存储设备的访问速度慢，与内存相比要慢几个数量级。大量频繁的存储设备访问操作会成为应用程序的性能瓶颈。&lt;/p&gt;
&lt;h2 id=&#34;1-访问粒度不一致问题和一些优化&#34;&gt;1 访问粒度不一致问题和一些优化&lt;/h2&gt;
&lt;p&gt;​		文件系统使用内存作为中转来解决访问粒度不—致的问题。假设一个存储设备的块大小为 4KB。当文件系统需要修改存储设备中的 8B 时，其需要先从存储设备中找到这8个字节所在的块号。通过块号，文件系统将整个块中的数据读入一个 4KB 大小的内存页之中。文件系统在内存页中修改这8个字节，并将修改后的内存页通过驱动写回到存储设备之中。这实际上是一个“读取—修改—写回”的过程。&lt;/p&gt;
&lt;p&gt;​		其中一个明显的问题是，若每个文件请求中每个结构的修改都经过完整的 “&lt;strong&gt;读取-修改-写回&lt;/strong&gt;” 过程，将会产生大量的磁盘访问。有一些比较简单的优化可以避免一些不必要的磁盘访问。&lt;/p&gt;
&lt;p&gt;​		之所以要在修改和写回之前先读取，是因为我们只想修改存储块下的一部分，而写回操作会覆盖整个存储块。为了保证此存储块中其他部分的数据不变，我们需要先将这些数据读出来，之后随修改后的数据一同写回到存储设备中。但是，如果一次修改的数据量刚好覆盖了整个存储块，那么就不用进行读取操作，可以直接将修改后的4096个字节写回到存储设备中。&lt;/p&gt;
&lt;p&gt;​		此外，如果一个文件请求中的多次修改均是在同—个存储块中，那么可以将多次修改合并到一个 “&lt;strong&gt;读取-修改-写回&lt;/strong&gt;” 的过程中，即变为 “&lt;strong&gt;读取-修改1-修改2-修改3-…修改n-写回&lt;/strong&gt;” 。这样，同样访问了两次存储设备，却完成了多次修改。&lt;/p&gt;
&lt;h2 id=&#34;2-读缓存&#34;&gt;2 读缓存&lt;/h2&gt;
&lt;p&gt;​		文件的访问具有时间局部性：当文件的一部分被访问后，有较高的概率其会再次被使用。因此，当文件系统从设备中读取了某个文件的数据之后，可以让这些数据继续保留在内存中一段时间。这样，当应用程序需要再次读取这些数据时，就可以从此前保留在内存中的数据中读取，从而避免了存储设备的访问。这便是文件系统中的读缓存。&lt;/p&gt;
&lt;p&gt;​		读缓存是需要占用内存空间的。为了防止该缓存占用过多的内存，澡作系统会对读缓存的大小进行限制。当读缓存占用过多内存时，使用 LRU 等策略回收读缓存占用的内存。&lt;/p&gt;
&lt;h2 id=&#34;3-写缓冲区和写合并&#34;&gt;3 写缓冲区和写合并&lt;/h2&gt;
&lt;p&gt;​		一般默认一个写请求结束之后，所有的写入数据均已被持久化到存储设备上，也就是说在文件写入请求完成后立刻发生断电和崩溃等情况，在系统恢复后，刚刚写入的文件数据依然能够被读取到。这是一个较强但十分合理的保证。然而由于存储设备的性能较差，若每个写请求均等待写入设备完成，文件写操作的延时变长，吞吐量会严重下降，从而影响整个系统的性能。&lt;/p&gt;
&lt;p&gt;​		为了获得更好的性能，在文件系统的设计中有一个权衡：在—个文件写请求返回到应用程序之后，允许其修改的数据暂时不持久化到存储设备中。这个权衡允许文件系统暂时将修改的数据保存在内存中，并在后台慢慢地持久化到存储设备上，然而这样却牺牲了—定的可靠性。在前面的例子中，如果在文件写请求完成后立刻发生断电，再次开机之后，刚刚完成写入的数据可能会丢失。为了确保数据被持久化到设备中，POSIX 中规定了 &lt;strong&gt;fsync&lt;/strong&gt; 接口，用于保证某个已打开文件的所有修改全部被持久化到存储设备中。&lt;/p&gt;
&lt;p&gt;​		当文件系统修改完文件数据后，其修改会被暂存在写缓冲区的内存页之中。如果后续的文件请求需要读取或者修改相同存储块中的数据，文件系统可以直接在写缓冲区对应的内存页上进行读取或者修改。当可用内存不足，或者对应的 &lt;strong&gt;fsync&lt;/strong&gt; 被调用时，写缓冲区内存页中的数据才写回到存储设备对应的存储块之中。这样，一段时间内同一个存储块上的多个写请求可以合并一个磁盘写操作。&lt;/p&gt;
&lt;h2 id=&#34;4-页缓存&#34;&gt;4 页缓存&lt;/h2&gt;
&lt;p&gt;​		在Linux内核中，读缓存与写缓冲区的功能被合并起来管理，称为页缓存。页缓存以内存页为单位，将存储设备中的存储位置映射到内存中。文件系统通过调用 VFS 提供的相应接口对页缓存进行操作。&lt;/p&gt;
&lt;p&gt;​		当—个文件被读取时，文件系统会先检查其内容是否已经保存在页缓存中。如果文件数据已保存在页缓存中，则文件系统直接从页缓存中读取数据返回给应用程序；否则，文件系统会在页缓存中创建新的内存页，并从存储设备中读取相关的数据然后将其保存在创建的内存页中。之后，文件系统从内存页中读取相应的数据，返回给应用程序。&lt;/p&gt;
&lt;p&gt;​		在进行文件修改时，文件系统同样会首先检查页缓存。如果要修改的数据已经在页缓存中，文件系统可以直接修改页缓存中的数据，并将该页标记为脏页；若不在页缓存中，文件系统同样先创建页缓存并从存储没备中读取数据，然后在页缓存中进行修改并标记该页为脏页。标记为脏页的缓存会由文件系统定期写回到存储设备中。当操作系统内存不足或者应用程序调用 &lt;strong&gt;fsync&lt;/strong&gt; 时，文件系统也会将脏页中的数据写回到存储设备中。&lt;/p&gt;
&lt;h2 id=&#34;5-直接io&#34;&gt;5 直接IO&lt;/h2&gt;
&lt;p&gt;​		&lt;strong&gt;直接IO&lt;/strong&gt;就是不需要读缓冲，不需要写缓冲区和写合并。&lt;/p&gt;
&lt;p&gt;​		页缓存是持久化和性能之间权衡的产物。在大多数情况下，页缓存能够显著地提升文件系统性能。然而并非在所有情况下页缓存都能起到正面作用。一方面，部分应用对数据持久化有较强的要求，不希望文件的修改内容缓存在页缓存中。如果使用页缓存的机制，这些应用需要在每次修改文件后立即执行 &lt;strong&gt;fsync&lt;/strong&gt; 操作进行同步，这会影响应用程序的性能。另一方面，一些应用程序（如数据库等）会自己实现缓存机制对数据进行缓存和管理。由于应用程序更加了解自己对数据的需求,在这种情况下，操作系统提供的页缓存机制是冗余的，且一般会带来额外的性能开销。&lt;/p&gt;
&lt;p&gt;​		因此，文件系统将是否使用页缓存的判断和选择权交给了应用程序。应用程序可以在打开文件时通过附带 &lt;strong&gt;O_DIRECT&lt;/strong&gt; 标志，提示文件系统不要使用页缓存。这种文件访问方式就是&lt;strong&gt;直接 I/O&lt;/strong&gt; 。而相对应地，使用页缓存的文件请求称为缓存I/O。&lt;/p&gt;
&lt;h2 id=&#34;6-内存映射&#34;&gt;6 内存映射&lt;/h2&gt;
&lt;p&gt;​		除了文件的 read 和 write 接口外，应用程序还可以通过内存映射机制，以访问内存的形式访问文件内容。Linux在其页缓存的基础上实现了文件的内存映射机制。&lt;/p&gt;
&lt;p&gt;​		将一个文件或者其它对象映射到进程虚拟地址空间，实现文件磁盘地址和进程虚拟地址空间中的地址一一对映关系。&lt;/p&gt;
&lt;p&gt;​		&lt;img src=&#34;http://ydsungan.com/post/mmap_1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;内存映射&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;7-页缓存与内存映射的区别&#34;&gt;7 页缓存与内存映射的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;页缓存IO中数据从块设备到页缓存，再到用户缓冲区，经过俩次拷贝；而 mmap 方式下，当发生缺页中断时才去磁盘拷贝，然后直接对内存读写。&lt;/li&gt;
&lt;li&gt;处理大文件时，页缓存IO方式使用 read/write 系统调用一块一块的双份拷贝，而 mmap 方式把文件映射到虚拟地址空间，可以让磁盘空间替代内存。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>使用Hugo平台搭建个人博客</title>
        <link>http://ydsungan.com/p/%E4%BD%BF%E7%94%A8hugo%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
        <pubDate>Tue, 22 Mar 2022 12:44:12 +0800</pubDate>
        
        <guid>http://ydsungan.com/p/%E4%BD%BF%E7%94%A8hugo%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
        <description>&lt;img src="http://ydsungan.com/post/hugo-logo-wide.svg" alt="Featured image of post 使用Hugo平台搭建个人博客" /&gt;&lt;h1 id=&#34;1-windows-10-安装-hugo&#34;&gt;1 Windows 10 安装 Hugo&lt;/h1&gt;
&lt;h2 id=&#34;11-安装-chocolatey-包管理器&#34;&gt;1.1 安装 Chocolatey 包管理器&lt;/h2&gt;
&lt;p&gt;windows 上需要使用 Chocolatey 作为包管理器，在安装 Hugo 之前需要在windows上安装 Chocolatey，以管理员方式运行PowerShell，输入以下指令自动安装 Chocolatey：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;Set-ExecutionPolicy&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bypass&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-Scope&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;Process&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-Force&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;[System.Net.ServicePointManager]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SecurityProtocol&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;[System.Net.ServicePointManager]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SecurityProtocol&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-bor&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;3072&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;iex &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;New-Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WebClient&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DownloadString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;https://chocolatey.org/install.ps1&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;输入命令 “choco” 来检查安装是否成功。&lt;/p&gt;
&lt;h2 id=&#34;12-安装-hugo&#34;&gt;1.2 安装 Hugo&lt;/h2&gt;
&lt;p&gt;接下来，输入以下命令来安装 Hugo：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;choco&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;install&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;hugo-extended&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-confirm&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;输入命令 “hugo help” 来检查安装是否成功。&lt;/p&gt;
&lt;h1 id=&#34;2-搭建项目&#34;&gt;2 搭建项目&lt;/h1&gt;
&lt;h2 id=&#34;21-建立项目&#34;&gt;2.1 建立项目&lt;/h2&gt;
&lt;p&gt;在 windows 的用户家目录下（C:\Users\username）输入以下命令（其中ydsungan为项目的名称）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;hugo&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;site&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ydsungan&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;22-下载主题&#34;&gt;2.2 下载主题&lt;/h2&gt;
&lt;p&gt;在【https://themes.gohugo.io/】网站选择一个主题，进入主题的 Github 页面，拷贝地址，进入项目的themes目录，克隆该主题：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cd themes
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/CaiJimmy/hugo-theme-stack.git
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;23-配置主题&#34;&gt;2.3 配置主题&lt;/h2&gt;
&lt;p&gt;在themes目录里有下载好的hugo-theme-stack文件夹，该文件夹里面的 exampleSite/config.ymal 就是配置文件，需要把该配置文件复制到项目的根目录下，直接覆盖根目录下的原有的配置文件（config.ymal 或者config.toml）。&lt;/p&gt;
&lt;p&gt;如果根目录下有 config.toml 而没有 config.ymal 文件，那么把 config.toml 直接删除即可，把 exampleSite/config.ymal 直接黏贴在项目的根目录下。&lt;/p&gt;
&lt;h2 id=&#34;24-添加内容&#34;&gt;2.4 添加内容&lt;/h2&gt;
&lt;p&gt;项目根目录下执行 &lt;em&gt;hugo new about.md&lt;/em&gt; ，会在根目录下的 content 目录下生成一个about.md文件。该文件的默认内容为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;title: &amp;#34;About&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;date: 2018-05-22T22:04:26+08:00
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;draft: true
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;draft：表示该文章是否为草稿，true表示为草稿状态，草稿状态下是对外不可见的，提交后需要改为true；&lt;/p&gt;
&lt;p&gt;不过一般的博客文章都是放在根目录下的 &lt;em&gt;/content/post/&lt;/em&gt; 目录下的，执行 &lt;em&gt;hugo new post/test.md&lt;/em&gt; 会创建一个test.md。&lt;/p&gt;
&lt;h2 id=&#34;25-启动hugo自带的服务器&#34;&gt;2.5 启动Hugo自带的服务器&lt;/h2&gt;
&lt;p&gt;使用以下命令即可启动一个Hugo服务器&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; hugo server  --theme=hugo-theme-stack
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;启动后在浏览器输入 &lt;em&gt;http://127.0.0.1:1313&lt;/em&gt; 即可。&lt;/p&gt;
&lt;h2 id=&#34;26-生成静态网页&#34;&gt;2.6 生成静态网页&lt;/h2&gt;
&lt;p&gt;使用以下命令即可在根目录下的/public/里面生成静态的HTML&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hugo --theme=hugo-theme-stack --baseUrl=&amp;#34;http://ydsungan.com&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;27-上传-github-保存&#34;&gt;2.7 上传 Github 保存&lt;/h2&gt;
&lt;p&gt;在 Github 上新建一个仓库，把整个项目上传即可。然后在自己的服务器上拉取该项目即可。&lt;/p&gt;
&lt;h2 id=&#34;28-配置自己服务器上的-nginx&#34;&gt;2.8 配置自己服务器上的 Nginx&lt;/h2&gt;
&lt;p&gt;在自己的服务器上的 Nginx 的 conf/nginx.conf 文件里面配置如下即可：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;location / {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            root   /usr/local/ydsungan_hugo/public;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            index  index.html index.htm;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;ydsungan_hugo 就是从 Github 拉取的项目，而静态HTML就生成在 public/ 目录下；输入命令 &lt;em&gt;./sbin/nginx -s reload&lt;/em&gt; 重启 nginx 即可。现在可以在浏览器访问自己的服务器了。&lt;/p&gt;
&lt;h1 id=&#34;29-配置disqus评论&#34;&gt;2.9 配置disqus评论&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;首先注册&lt;strong&gt;disqus&lt;/strong&gt;账号，https://disqus.com，注册好之后，选择 “&lt;em&gt;I want to install Disqus on my site&lt;/em&gt;” ，如下图所示：&lt;img src=&#34;http://ydsungan.com/post/disqus_1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;disqus_1&#34;
	
	
&gt;&lt;/li&gt;
&lt;li&gt;关于 “What platform is your site on?” ，这里没有Hugo平台的选项，所以选择最下方的“Universal Code”通用代码的选项；&lt;/li&gt;
&lt;li&gt;然后把它给的如下代码放在项目根目录下的：layouts\partials\comments\provider文件夹中的disqus.html中，没有的话自己新建&lt;img src=&#34;http://ydsungan.com/post/disqus_2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;disqus_2&#34;
	
	
&gt;&lt;/li&gt;
&lt;li&gt;修改项目的配置文件，将comments设置为true，提供商为“disqus”，关于disqus的配置只需要写一个shortname即可，这个shortname是disqus平台注册的时候就有的。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;comments&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;enabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;provider&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;disqus&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;disqusjs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;shortname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ydsungan&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiUrl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;admin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;adminLabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        
    </channel>
</rss>
